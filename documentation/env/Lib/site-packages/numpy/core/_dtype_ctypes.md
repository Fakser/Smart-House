# Dtype Ctypes

> Auto-generated documentation for [env.Lib.site-packages.numpy.core._dtype_ctypes](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\_dtype_ctypes.py) module.

Conversion from ctypes to dtype.

- [Smart-house-rest-api](..\..\..\..\..\README.md#description) / [Modules](..\..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Numpy](..\index.md#numpy) / [Core](index.md#core) / Dtype Ctypes
    - [dtype_from_ctypes_type](#dtype_from_ctypes_type)

In an ideal world, we could achieve this through the PEP3118 buffer protocol,
something like

```python
def dtype_from_ctypes_type(t):
    # needed to ensure that the shape of `t` is within memoryview.format
    class DummyStruct(ctypes.Structure):
        _fields_ = [('a', t)]

    # empty to avoid memory allocation
    ctype_0 = (DummyStruct * 0)()
    mv = memoryview(ctype_0)

    # convert the struct, and slice back out the field
    return _dtype_from_pep3118(mv.format)['a']
```

Unfortunately, this fails because:

* ctypes cannot handle length-0 arrays with PEP3118 (bpo-32782)
* PEP3118 cannot represent unions, but both numpy and ctypes can
* ctypes cannot handle big-endian structs with PEP3118 (bpo-32780)

## dtype_from_ctypes_type

[[find in source code]](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\_dtype_ctypes.py#L100)

```python
def dtype_from_ctypes_type(t):
```

Construct a dtype object from a ctypes type
