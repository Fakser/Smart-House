# Records

> Auto-generated documentation for [env.Lib.site-packages.numpy.core.records](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\records.py) module.

Record Arrays
=============
Record arrays expose the fields of structured arrays as properties.

- [Smart-house-rest-api](..\..\..\..\..\README.md#description) / [Modules](..\..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Numpy](..\index.md#numpy) / [Core](index.md#core) / Records
    - [format_parser](#format_parser)
    - [recarray](#recarray)
        - [recarray().field](#recarrayfield)
    - [record](#record)
        - [record().pprint](#recordpprint)

Most commonly, ndarrays contain elements of a single type, e.g. floats,
integers, bools etc.  However, it is possible for elements to be combinations
of these using structured types, such as

```python
>>> a = np.array([(1, 2.0), (1, 2.0)], dtype=[('x', np.int64), ('y', np.float64)])
>>> a
array([(1, 2.), (1, 2.)], dtype=[('x', '<i8'), ('y', '<f8')])
```

Here, each element consists of two fields: x (and int), and y (a float).
This is known as a structured array.  The different fields are analogous
to columns in a spread-sheet.  The different fields can be accessed as
one would a dictionary

```python
>>> a['x']
array([1, 1])
```

```python
>>> a['y']
array([2., 2.])
```

Record arrays allow us to access fields as properties

```python
>>> ar = np.rec.array(a)
```

```python
>>> ar.x
array([1, 1])
```

```python
>>> ar.y
array([2., 2.])

## format_parser

[[find in source code]](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\records.py#L97)

```python
set_module('numpy')
class format_parser():
    def __init__(formats, names, titles, aligned=False, byteorder=None):
```

Class to convert formats, names, titles description to a dtype.

After constructing the format_parser object, the dtype attribute is
the converted data-type:
``dtype = format_parser(formats, names, titles).dtype``

Attributes
----------
dtype : dtype
    The converted data-type.

Parameters
----------
formats : str or list of str
    The format description, either specified as a string with
    comma-separated format descriptions in the form ``'f8, i4, a5'``, or
    a list of format description strings  in the form
    ``['f8', 'i4', 'a5']``.
names : str or list/tuple of str
    The field names, either specified as a comma-separated string in the
    form ``'col1, col2, col3'``, or as a list or tuple of strings in the
    form ``['col1', 'col2', 'col3']``.
    An empty list can be used, in that case default field names
    ('f0', 'f1', ...) are used.
titles : sequence
    Sequence of title strings. An empty list can be used to leave titles
    out.
aligned : bool, optional
    If True, align the fields by padding as the C-compiler would.
    Default is False.
byteorder : str, optional
    If specified, all the fields will be changed to the
    provided byte-order.  Otherwise, the default byte-order is
    used. For all available string specifiers, see `dtype.newbyteorder`.

See Also
--------
dtype, typename, sctype2char

Examples
--------

```python
>>> np.format_parser(['<f8', '<i4', '<a5'], ['col1', 'col2', 'col3'],
...                  ['T1', 'T2', 'T3']).dtype
dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'), (('T3', 'col3'), 'S5')])
```

`names` and/or `titles` can be empty lists. If `titles` is an empty list,
titles will simply not appear. If `names` is empty, default field names
will be used.

```python
>>> np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],
...                  []).dtype
dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '<S5')])
>>> np.format_parser(['<f8', '<i4', '<a5'], [], []).dtype
dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', 'S5')])

## recarray

[[find in source code]](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\records.py#L318)

```python
class recarray(ndarray):
```

Construct an ndarray that allows field access using attributes.

Arrays may have a data-types containing fields, analogous
to columns in a spread sheet.  An example is ``[(x, int), (y, float)]``,
where each entry in the array is a pair of ``(int, float)``.  Normally,
these attributes are accessed using dictionary lookups such as ``arr['x']``
and ``arr['y']``.  Record arrays allow the fields to be accessed as members
of the array, using ``arr.x`` and ``arr.y``.

Parameters
----------
shape : tuple
    Shape of output array.
dtype : data-type, optional
    The desired data-type.  By default, the data-type is determined
    from `formats`, `names`, `titles`, `aligned` and `byteorder`.
formats : list of data-types, optional
    A list containing the data-types for the different columns, e.g.
    ``['i4', 'f8', 'i4']``.  `formats` does *not* support the new
    convention of using types directly, i.e. ``(int, float, int)``.
    Note that `formats` must be a list, not a tuple.
    Given that `formats` is somewhat limited, we recommend specifying
    `dtype` instead.
names : tuple of str, optional
    The name of each column, e.g. ``('x', 'y', 'z')``.
buf : buffer, optional
    By default, a new array is created of the given shape and data-type.
    If `buf` is specified and is an object exposing the buffer interface,
    the array will use the memory from the existing buffer.  In this case,
    the `offset` and `strides` keywords are available.

Other Parameters
----------------
titles : tuple of str, optional
    Aliases for column names.  For example, if `names` were
    ``('x', 'y', 'z')`` and `titles` is
    ``('x_coordinate', 'y_coordinate', 'z_coordinate')``, then
    ``arr['x']`` is equivalent to both ``arr.x`` and ``arr.x_coordinate``.
byteorder : {'<', '>', '='}, optional
    Byte-order for all fields.
aligned : bool, optional
    Align the fields in memory as the C-compiler would.
strides : tuple of ints, optional
    Buffer (`buf`) is interpreted according to these strides (strides
    define how many bytes each array element, row, column, etc.
    occupy in memory).
offset : int, optional
    Start reading buffer (`buf`) from this offset onwards.
order : {'C', 'F'}, optional
    Row-major (C-style) or column-major (Fortran-style) order.

Returns
-------
rec : recarray
    Empty array of the given shape and type.

See Also
--------
rec.fromrecords : Construct a record array from data.
record : fundamental data-type for [recarray](#recarray).
format_parser : determine a data-type from formats, names, titles.

Notes
-----
This constructor can be compared to ``empty``: it creates a new record
array but does not fill it with data.  To create a record array from data,
use one of the following methods:

1. Create a standard ndarray and convert it to a record array,
   using ``arr.view(np.recarray)``
2. Use the `buf` keyword.
3. Use `np.rec.fromrecords`.

Examples
--------
Create an array with two fields, ``x`` and ``y``:

```python
>>> x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '<f8'), ('y', '<i8')])
>>> x
array([(1., 2), (3., 4)], dtype=[('x', '<f8'), ('y', '<i8')])
```

```python
>>> x['x']
array([1., 3.])
```

View the array as a record array:

```python
>>> x = x.view(np.recarray)
```

```python
>>> x.x
array([1., 3.])
```

```python
>>> x.y
array([2, 4])
```

Create a new, empty record array:

```python
>>> np.recarray((2,),
... dtype=[('x', int), ('y', float), ('z', int)]) #doctest: +SKIP
rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),
       (3471280, 1.2134086255804012e-316, 0)],
      dtype=[('x', '<i4'), ('y', '<f8'), ('z', '<i4')])

#### See also

- [ndarray](#ndarray)

### recarray().field

[[find in source code]](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\records.py#L566)

```python
def field(attr, val=None):
```

## record

[[find in source code]](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\records.py#L233)

```python
class record(nt.void):
```

A data-type scalar that allows field access as attribute lookup.

### record().pprint

[[find in source code]](..\..\..\..\..\..\env\Lib\site-packages\numpy\core\records.py#L301)

```python
def pprint():
```

Pretty-print all fields.
