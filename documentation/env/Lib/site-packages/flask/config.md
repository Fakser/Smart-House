# flask.config

> Auto-generated documentation for [env.Lib.site-packages.flask.config](..\..\..\..\..\env\Lib\site-packages\flask\config.py) module.

Implements the configuration related objects.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [flask](index.md#flask) / flask.config
    - [Config](#config)
        - [Config().from_envvar](#configfrom_envvar)
        - [Config().from_json](#configfrom_json)
        - [Config().from_mapping](#configfrom_mapping)
        - [Config().from_object](#configfrom_object)
        - [Config().from_pyfile](#configfrom_pyfile)
        - [Config().get_namespace](#configget_namespace)
    - [ConfigAttribute](#configattribute)

:copyright: 2010 Pallets
:license: BSD-3-Clause

## Config

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L41)

```python
class Config(dict):
    def __init__(root_path, defaults=None):
```

Works exactly like a dict but provides ways to fill it from files
or special dictionaries.  There are two common patterns to populate the
config.

Either you can fill the config from a config file

```python
app.config.from_pyfile('yourconfig.cfg')
```

Or alternatively you can define the configuration options in the
module that calls :meth:`from_object` or provide an import path to
a module that should be loaded.  It is also possible to tell it to
use the same module and with that provide the configuration values
just before the call

```python
DEBUG = True
SECRET_KEY = 'development key'
app.config.from_object(__name__)
```

In both cases (loading from any Python file or loading from modules),
only uppercase keys are added to the config.  This makes it possible to use
lowercase values in the config file for temporary values that are not added
to the config or to define the config keys in the same file that implements
the application.

Probably the most interesting way to load configurations is from an
environment variable pointing to a file

```python
app.config.from_envvar('YOURAPPLICATION_SETTINGS')
```

In this case before launching the application you have to set this
environment variable to the file you want to use.  On Linux and OS X
use the export statement

```python
export YOURAPPLICATION_SETTINGS='/path/to/config/file'
```

On windows use `set` instead.

#### Arguments

- `root_path` - path to which files are read relative from.  When the
                  config object is created by the application, this is
                  the application's attribute `~flask.Flask.root_path`.
- `defaults` - an optional dictionary of default values

### Config().from_envvar

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L89)

```python
def from_envvar(variable_name, silent=False):
```

Loads a configuration from an environment variable pointing to
a configuration file.  This is basically just a shortcut with nicer
error messages for this line of code

```python
app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])
```

#### Arguments

- `variable_name` - name of the environment variable
- `silent` - set to ``True`` if you want silent failure for missing
               files.

#### Returns

bool. ``True`` if able to load config, ``False`` otherwise.

### Config().from_json

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L179)

```python
def from_json(filename, silent=False):
```

Updates the values in the config from a JSON file. This function
behaves as if the JSON object was a dictionary and passed to the
:meth:[Config().from_mapping](#configfrom_mapping) function.

#### Arguments

- `filename` - the filename of the JSON file.  This can either be an
                 absolute filename or a filename relative to the
                 root path.
- `silent` - set to ``True`` if you want silent failure for missing
               files.

#### Notes

Added in version 0.11

### Config().from_mapping

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L204)

```python
def from_mapping(*mapping, **kwargs):
```

Updates the config like :meth:`update` ignoring items with non-upper
keys.

#### Notes

Added in version 0.11

### Config().from_object

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L141)

```python
def from_object(obj):
```

Updates the values from the given object.  An object can be of one
of the following two types:

-   a string: in this case the object with that name will be imported
-   an actual object reference: that object is used directly

Objects are usually either modules or classes. :meth:`from_object`
loads only the uppercase attributes of the module/class. A ``dict``
object will not work with :meth:`from_object` because the keys of a
``dict`` are not attributes of the ``dict`` class.

Example of module-based configuration

```python
app.config.from_object('yourapplication.default_config')
from yourapplication import default_config
app.config.from_object(default_config)
```

Nothing is done to the object before loading. If the object is a
class and has ``@property`` attributes, it needs to be
instantiated before being passed to this method.

You should not use this function to load the actual configuration but
rather configuration defaults.  The actual config should be loaded
with :meth:[Config().from_pyfile](#configfrom_pyfile) and ideally from a location not within the
package because the package might be installed system wide.

See :ref:`config-dev-prod` for an example of class-based configuration
using :meth:`from_object`.

#### Arguments

- `obj` - an import name or object

### Config().from_pyfile

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L113)

```python
def from_pyfile(filename, silent=False):
```

Updates the values in the config from a Python file.  This function
behaves as if the file was imported as module with the
:meth:[Config().from_object](#configfrom_object) function.

#### Arguments

- `filename` - the filename of the config.  This can either be an
                 absolute filename or a filename relative to the
                 root path.
- `silent` - set to ``True`` if you want silent failure for missing
               files.

#### Notes

Added in version 0.7
   `silent` parameter.

### Config().get_namespace

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L227)

```python
def get_namespace(namespace, lowercase=True, trim_namespace=True):
```

Returns a dictionary containing a subset of configuration options
that match the specified namespace/prefix. Example usage

```python
app.config['IMAGE_STORE_TYPE'] = 'fs'
app.config['IMAGE_STORE_PATH'] = '/var/app/images'
app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'
image_store_config = app.config.get_namespace('IMAGE_STORE_')
```

The resulting dictionary `image_store_config` would look like

```python
{
    'type': 'fs',
    'path': '/var/app/images',
    'base_url': 'http://img.website.com'
}
```

This is often useful when configuration options map directly to
keyword arguments in functions or class constructors.

#### Arguments

- `namespace` - a configuration namespace
- `lowercase` - a flag indicating if the keys of the resulting
                  dictionary should be lowercase
- `trim_namespace` - a flag indicating if the keys of the resulting
                  dictionary should not include the namespace

#### Notes

Added in version 0.11

## ConfigAttribute

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\config.py#L22)

```python
class ConfigAttribute(object):
    def __init__(name, get_converter=None):
```

Makes an attribute forward to the config
