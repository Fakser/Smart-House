# flask.ctx

> Auto-generated documentation for [env.Lib.site-packages.flask.ctx](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py) module.

Implements the objects required to keep the context.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [flask](index.md#flask) / flask.ctx
    - [AppContext](#appcontext)
        - [AppContext().pop](#appcontextpop)
        - [AppContext().push](#appcontextpush)
    - [RequestContext](#requestcontext)
        - [RequestContext().auto_pop](#requestcontextauto_pop)
        - [RequestContext().copy](#requestcontextcopy)
        - [RequestContext().g](#requestcontextg)
        - [RequestContext().g](#requestcontextg)
        - [RequestContext().match_request](#requestcontextmatch_request)
        - [RequestContext().pop](#requestcontextpop)
        - [RequestContext().push](#requestcontextpush)
    - [after_this_request](#after_this_request)
    - [copy_current_request_context](#copy_current_request_context)
    - [has_app_context](#has_app_context)
    - [has_request_context](#has_request_context)

:copyright: 2010 Pallets
:license: BSD-3-Clause

## AppContext

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L205)

```python
class AppContext(object):
    def __init__(app):
```

The application context binds an application object implicitly
to the current thread or greenlet, similar to how the
:class:[RequestContext](#requestcontext) binds request information.  The application
context is also implicitly created if a request context is created
but the application is not on top of the individual application
context.

### AppContext().pop

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L231)

```python
def pop(exc=_sentinel):
```

Pops the app context.

### AppContext().push

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L223)

```python
def push():
```

Binds the app context to the current context.

## RequestContext

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L255)

```python
class RequestContext(object):
    def __init__(app, environ, request=None, session=None):
```

The request context contains all request relevant information.  It is
created at the beginning of the request and pushed to the
`_request_ctx_stack` and removed at the end of it.  It will create the
URL adapter and request object for the WSGI environment provided.

Do not attempt to use this class directly, instead use
:meth:`~flask.Flask.test_request_context` and
:meth:`~flask.Flask.request_context` to create this object.

When the request context is popped, it will evaluate all the
functions registered on the application for teardown execution
(:meth:`~flask.Flask.teardown_request`).

The request context is automatically popped at the end of the request
for you.  In debug mode the request context is kept around if
exceptions happen so that interactive debuggers have a chance to
introspect the data.  With 0.4 this can also be forced for requests
that did not fail and outside of ``DEBUG`` mode.  By setting
``'flask._preserve_context'`` to ``True`` on the WSGI environment the
context will not pop itself at the end of the request.  This is used by
the :meth:`~flask.Flask.test_client` for example to implement the
deferred cleanup functionality.

You might find this helpful for unittests where you need the
information from the context local around for a little longer.  Make
sure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in
that situation, otherwise your unittests will leak memory.

### RequestContext().auto_pop

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L445)

```python
def auto_pop(exc):
```

### RequestContext().copy

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L325)

```python
def copy():
```

Creates a copy of this request context with the same request object.
This can be used to move a request context to a different greenlet.
Because the actual request object is the same this cannot be used to
move a request context to a different thread unless access to the
request object is locked.

#### Notes

Added in version 0.10

Changed in version 1.1
   The current session object is used instead of reloading the original
   data. This prevents `flask.session` pointing to an out-of-date object.

### RequestContext().g

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L317)

```python
@property
def g():
```

### RequestContext().g

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L321)

```python
@g.setter
def g(value):
```

### RequestContext().match_request

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L345)

```python
def match_request():
```

Can be overridden by a subclass to hook into the matching
of the request.

### RequestContext().pop

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L398)

```python
def pop(exc=_sentinel):
```

Pops the request context and unbinds it by doing that.  This will
also trigger the execution of functions registered by the
:meth:`~flask.Flask.teardown_request` decorator.

#### Notes

Changed in version 0.9
   Added the `exc` argument.

### RequestContext().push

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L355)

```python
def push():
```

Binds the request context to the current context.

## after_this_request

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L98)

```python
def after_this_request(f):
```

Executes a function after this request.  This is useful to modify
response objects.  The function is passed the response object and has
to return the same or a new one.

Example

```python
@app.route('/')
def index():
    @after_this_request
    def add_header(response):
        response.headers['X-Foo'] = 'Parachute'
        return response
    return 'Hello World!'
```

This is more useful if a function other than the view function wants to
modify a response.  For instance think of a decorator that wants to add
some headers without converting the return value into a response object.

#### Notes

Added in version 0.9

## copy_current_request_context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L123)

```python
def copy_current_request_context(f):
```

A helper function that decorates a function to retain the current
request context.  This is useful when working with greenlets.  The moment
the function is decorated a copy of the request context is created and
then pushed when the function is called.  The current session is also
included in the copied request context.

Example

```python
import gevent
from flask import copy_current_request_context

@app.route('/')
def index():
    @copy_current_request_context
    def do_some_work():
        # do some work here, it can access flask.request or
        # flask.session like you would otherwise in the view function.
        ...
    gevent.spawn(do_some_work)
    return 'Regular response'
```

#### Notes

Added in version 0.10

## has_app_context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L195)

```python
def has_app_context():
```

Works like :func:[has_request_context](#has_request_context) but for the application
context.  You can also just do a boolean check on the
`current_app` object instead.

#### Notes

Added in version 0.9

## has_request_context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\ctx.py#L163)

```python
def has_request_context():
```

If you have code that wants to test if a request context is there or
not this function can be used.  For instance, you may want to take advantage
of request information if the request object is available, but fail
silently if it is unavailable.

```python
class User(db.Model):

    def __init__(self, username, remote_addr=None):
        self.username = username
        if remote_addr is None and has_request_context():
            remote_addr = request.remote_addr
        self.remote_addr = remote_addr
```

Alternatively you can also just test any of the context bound objects
(such as class `request` or class `g`) for truthness

```python
class User(db.Model):

    def __init__(self, username, remote_addr=None):
        self.username = username
        if remote_addr is None and request:
            remote_addr = request.remote_addr
        self.remote_addr = remote_addr
```

#### Notes

Added in version 0.7
