# flask.helpers

> Auto-generated documentation for [env.Lib.site-packages.flask.helpers](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py) module.

Implements various helpers.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [flask](index.md#flask) / flask.helpers
    - [locked_cached_property](#locked_cached_property)
    - [find_package](#find_package)
    - [flash](#flash)
    - [get_debug_flag](#get_debug_flag)
    - [get_env](#get_env)
    - [get_flashed_messages](#get_flashed_messages)
    - [get_load_dotenv](#get_load_dotenv)
    - [get_root_path](#get_root_path)
    - [get_template_attribute](#get_template_attribute)
    - [is_ip](#is_ip)
    - [make_response](#make_response)
    - [safe_join](#safe_join)
    - [send_file](#send_file)
    - [send_from_directory](#send_from_directory)
    - [stream_with_context](#stream_with_context)
    - [total_seconds](#total_seconds)
    - [url_for](#url_for)

:copyright: 2010 Pallets
:license: BSD-3-Clause

## locked_cached_property

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L936)

```python
class locked_cached_property(object):
    def __init__(func, name=None, doc=None):
```

A decorator that converts a function into a lazy property.  The
function wrapped is called the first time to retrieve the result
and then that calculated result is used the next time you access
the value.  Works like the one in Werkzeug but has a lock for
thread safety.

## find_package

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L908)

```python
def find_package(import_name):
```

Finds a package and returns the prefix (or None if the package is
not installed) as well as the folder that contains the package or
module as a tuple.  The package path returned is the module that would
have to be added to the pythonpath in order to make it possible to
import the module.  The prefix is the path below which a UNIX like
folder structure exists (lib, share etc.).

## flash

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L399)

```python
def flash(message, category='message'):
```

Flashes a message to the next request.  In order to remove the
flashed message from the session and to display it to the user,
the template has to call :func:[get_flashed_messages](#get_flashed_messages).

#### Notes

Changed in version 0.3
   `category` parameter added.

#### Arguments

- `message` - the message to be flashed.
- `category` - the category for the message.  The following values
                 are recommended: ``'message'`` for any kind of message,
                 ``'error'`` for errors, ``'info'`` for information
                 messages and ``'warning'`` for warnings.  However any
                 kind of string can be used as category.

## get_debug_flag

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L64)

```python
def get_debug_flag():
```

Get whether debug mode should be enabled for the app, indicated
by the :envvar:`FLASK_DEBUG` environment variable. The default is
``True`` if :func:`.get_env` returns ``'development'``, or ``False``
otherwise.

## get_env

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L56)

```python
def get_env():
```

Get the environment the app is running in, indicated by the
:envvar:`FLASK_ENV` environment variable. The default is
``'production'``.

## get_flashed_messages

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L429)

```python
def get_flashed_messages(with_categories=False, category_filter=()):
```

Pulls all flashed messages from the session and returns them.
Further calls in the same request to the function will return
the same messages.  By default just the messages are returned,
but when `with_categories` is set to ``True``, the return value will
be a list of tuples in the form ``(category, message)`` instead.

Filter the flashed messages to one or more categories by providing those
categories in `category_filter`.  This allows rendering categories in
separate html blocks.  The `with_categories` and `category_filter`
arguments are distinct:

* `with_categories` controls whether categories are returned with message
  text (``True`` gives a tuple, where ``False`` gives just the message text).
* `category_filter` filters the messages down to only those matching the
  provided categories.

See :ref:`message-flashing-pattern` for examples.

#### Notes

Changed in version 0.3
   `with_categories` parameter added.

Changed in version 0.9
    `category_filter` parameter added.

#### Arguments

- `with_categories` - set to ``True`` to also receive categories.
- `category_filter` - whitelist of categories to limit return values

## get_load_dotenv

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L78)

```python
def get_load_dotenv(default=True):
```

Get whether the user has disabled loading dotenv files by setting
:envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load the
files.

#### Arguments

- `default` - What to return if the env var isn't set.

## get_root_path

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L774)

```python
def get_root_path(import_name):
```

Returns the path to a package or cwd if that cannot be found.  This
returns the path of a package or the folder that contains a module.

Not to be confused with the package path returned by :func:[find_package](#find_package).

## get_template_attribute

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L377)

```python
def get_template_attribute(template_name, attribute):
```

Loads a macro (or variable) a template exports.  This can be used to
invoke a macro from within Python code.  If you for example have a
template named :file:`_cider.html` with the following contents:

html+jinja

{% macro hello(name) %}Hello {{ name }}!{% endmacro %}

You can access this from Python code like this

```python
hello = get_template_attribute('_cider.html', 'hello')
return hello('World')
```

#### Notes

Added in version 0.2

#### Arguments

- `template_name` - the name of the template
- `attribute` - the name of the variable of macro to access

## is_ip

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L1128)

```python
def is_ip(value):
```

Determine if the given string is an IP address.

Python 2 on Windows doesn't provide ``inet_pton``, so this only
checks IPv4 addresses in that environment.

#### Arguments

- `value` - value to check
:type value: str

#### Returns

True if string is an IP address
Type: *bool*

## make_response

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L177)

```python
def make_response(*args):
```

Sometimes it is necessary to set additional headers in a view.  Because
views do not have to return response objects but can return a value that
is converted into a response object by Flask itself, it becomes tricky to
add headers to it.  This function can be called instead of using a return
and you will get a response object which you can use to attach headers.

If view looked like this and you want to add a new header

```python
def index():
    return render_template('index.html', foo=42)
```

You can now do something like this

```python
def index():
    response = make_response(render_template('index.html', foo=42))
    response.headers['X-Parachutes'] = 'parachutes are cool'
    return response
```

This function accepts the very same arguments you can return from a
view function.  This for example creates a response with a 404 error
code

```python
response = make_response(render_template('not_found.html'), 404)
```

The other use case of this function is to force the return value of a
view function into a response which is helpful with view
decorators

```python
response = make_response(view_function())
response.headers['X-Parachutes'] = 'parachutes are cool'
```

Internally this function does the following things:

-   if no arguments are passed, it creates a new response argument
-   if one argument is passed, :meth:`flask.Flask.make_response`
    is invoked with it.
-   if more than one argument is passed, the arguments are passed
    to the :meth:`flask.Flask.make_response` function as tuple.

#### Notes

Added in version 0.6

## safe_join

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L696)

```python
def safe_join(directory, *pathnames):
```

Safely join `directory` and zero or more untrusted `pathnames`
components.

Example usage

```python
@app.route('/wiki/<path:filename>')
def wiki_page(filename):
    filename = safe_join(app.config['WIKI_FOLDER'], filename)
    with open(filename, 'rb') as fd:
        content = fd.read()  # Read and process the file content...
```

#### Arguments

- `directory` - the trusted base directory.
- `pathnames` - the untrusted pathnames relative to that directory.
:raises: class `werkzeug.exceptions.NotFound` if one or more passed
        paths fall out of its boundaries.

## send_file

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L469)

```python
def send_file(
    filename_or_fp,
    mimetype=None,
    as_attachment=False,
    attachment_filename=None,
    add_etags=True,
    cache_timeout=None,
    conditional=False,
    last_modified=None,
):
```

Sends the contents of a file to the client.  This will use the
most efficient method available and configured.  By default it will
try to use the WSGI server's file_wrapper support.  Alternatively
you can set the application's attribute `~Flask.use_x_sendfile` attribute
to ``True`` to directly emit an ``X-Sendfile`` header.  This however
requires support of the underlying webserver for ``X-Sendfile``.

By default it will try to guess the mimetype for you, but you can
also explicitly provide one.  For extra security you probably want
to send certain files as attachment (HTML for instance).  The mimetype
guessing requires a `filename` or an `attachment_filename` to be
provided.

ETags will also be attached automatically if a `filename` is provided. You
can turn this off by setting `add_etags=False`.

If `conditional=True` and `filename` is provided, this method will try to
upgrade the response stream to support range requests.  This will allow
the request to be answered with partial content response.

Please never pass filenames to this function from user sources;
you should use :func:[send_from_directory](#send_from_directory) instead.

#### Notes

Added in version 0.2

Added in version 0.5
   The `add_etags`, `cache_timeout` and `conditional` parameters were
   added.  The default behavior is now to attach etags.

Changed in version 0.7
   mimetype guessing and etag support for file objects was
   deprecated because it was unreliable.  Pass a filename if you are
   able to, otherwise attach an etag yourself.  This functionality
   will be removed in Flask 1.0

Changed in version 0.9
   cache_timeout pulls its default from application config, when None.

Changed in version 0.12
   The filename is no longer automatically inferred from file objects. If
   you want to use automatic mimetype and etag support, pass a filepath via
   `filename_or_fp` or `attachment_filename`.

Changed in version 0.12
   The `attachment_filename` is preferred over `filename` for MIME-type
   detection.

Changed in version 1.0
    UTF-8 filenames, as specified in `RFC 2231`_, are supported.

.. _RFC 2231: https://tools.ietf.org/html/rfc2231#section-4

Changed in version 1.0.3
    Filenames are encoded with ASCII instead of Latin-1 for broader
    compatibility with WSGI servers.

Changed in version 1.1
    Filename may be a class `os.PathLike` object.

Added in version 1.1
    Partial content supports class `io.BytesIO`.

#### Arguments

- `filename_or_fp` - the filename of the file to send.
                       This is relative to the attribute `~Flask.root_path`
                       if a relative path is specified.
                       Alternatively a file object might be provided in
                       which case ``X-Sendfile`` might not work and fall
                       back to the traditional method.  Make sure that the
                       file pointer is positioned at the start of data to
                       send before calling :func:[send_file](#send_file).
- `mimetype` - the mimetype of the file if provided. If a file path is
                 given, auto detection happens as fallback, otherwise an
                 error will be raised.
- `as_attachment` - set to ``True`` if you want to send this file with
                      a ``Content-Disposition: attachment`` header.
- `attachment_filename` - the filename for the attachment if it
                            differs from the file's filename.
- `add_etags` - set to ``False`` to disable attaching of etags.
- `conditional` - set to ``True`` to enable conditional responses.

- `cache_timeout` - the timeout in seconds for the headers. When ``None``
                      (default), this value is set by
                      :meth:`~Flask.get_send_file_max_age` of
                      `~flask.current_app`.
- `last_modified` - set the ``Last-Modified`` header to this value,
    a class `datetime.datetime` or timestamp.
    If a file was passed, this overrides its mtime.

## send_from_directory

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L733)

```python
def send_from_directory(directory, filename, **options):
```

Send a file from a given directory with :func:[send_file](#send_file).  This
is a secure way to quickly expose static files from an upload folder
or something similar.

Example usage

```python
@app.route('/uploads/<path:filename>')
def download_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'],
                               filename, as_attachment=True)
```

Sending files and Performance

It is strongly recommended to activate either ``X-Sendfile`` support in
your webserver or (if no authentication happens) to tell the webserver
to serve files for the given path on its own without calling into the
web application for improved performance.

#### Notes

Added in version 0.5

#### Arguments

- `directory` - the directory where all the files are stored.
- `filename` - the filename relative to that directory to
                 download.
- `options` - optional keyword arguments that are directly
                forwarded to :func:[send_file](#send_file).

## stream_with_context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L101)

```python
def stream_with_context(generator_or_function):
```

Request contexts disappear when the response is started on the server.
This is done for efficiency reasons and to make it less likely to encounter
memory leaks with badly written WSGI middlewares.  The downside is that if
you are using streamed responses, the generator cannot access request bound
information any more.

This function however can help you keep the context around for longer

```python
from flask import stream_with_context, request, Response

@app.route('/stream')
def streamed_response():
    @stream_with_context
    def generate():
        yield 'Hello '
        yield request.args['name']
        yield '!'
    return Response(generate())
```

Alternatively it can also be used around a specific generator

```python
from flask import stream_with_context, request, Response

@app.route('/stream')
def streamed_response():
    def generate():
        yield 'Hello '
        yield request.args['name']
        yield '!'
    return Response(stream_with_context(generate()))
```

#### Notes

Added in version 0.9

## total_seconds

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L1117)

```python
def total_seconds(td):
```

Returns the total seconds from a timedelta object.

#### Arguments

- `td` *timedelta* - the timedelta to be converted in seconds

#### Returns

number of seconds
Type: *int*

## url_for

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\helpers.py#L226)

```python
def url_for(endpoint, **values):
```

Generates a URL to the given endpoint with the method provided.

Variable arguments that are unknown to the target endpoint are appended
to the generated URL as query arguments.  If the value of a query argument
is ``None``, the whole pair is skipped.  In case blueprints are active
you can shortcut references to the same blueprint by prefixing the
local endpoint with a dot (``.``).

This will reference the index function local to the current blueprint

```python
url_for('.index')
```

For more information, head over to the :ref:`Quickstart <url-building>`.

Configuration values ``APPLICATION_ROOT`` and ``SERVER_NAME`` are only used when
generating URLs outside of a request context.

To integrate applications, class `Flask` has a hook to intercept URL build
errors through attribute `Flask.url_build_error_handlers`.  The [url_for](#url_for)
function results in a exception `~werkzeug.routing.BuildError` when the current
app does not have a URL for the given endpoint and values.  When it does, the
`~flask.current_app` calls its attribute `~Flask.url_build_error_handlers` if
it is not ``None``, which can return a string to use as the result of
[url_for](#url_for) (instead of [url_for](#url_for)'s default to raise the
exception `~werkzeug.routing.BuildError` exception) or re-raise the exception.
An example

```python
def external_url_handler(error, endpoint, values):
    "Looks up an external URL when [url_for](#url_for) cannot build a URL."
    # This is an example of hooking the build_error_handler.
    # Here, lookup_url is some utility function you've built
    # which looks up the endpoint in some external URL registry.
    url = lookup_url(endpoint, **values)
    if url is None:
        # External lookup did not have a URL.
        # Re-raise the BuildError, in context of original traceback.
        exc_type, exc_value, tb = sys.exc_info()
        if exc_value is error:
            raise exc_type, exc_value, tb
        else:
            raise error
    # url_for will use this result, instead of raising BuildError.
    return url

app.url_build_error_handlers.append(external_url_handler)
```

Here, `error` is the instance of exception `~werkzeug.routing.BuildError`, and
`endpoint` and `values` are the arguments passed into [url_for](#url_for).  Note
that this is for building URLs outside the current application, and not for
handling 404 NotFound errors.

#### Notes

Added in version 0.10
   The `_scheme` parameter was added.

Added in version 0.9
   The `_anchor` and `_method` parameters were added.

Added in version 0.9
   Calls :meth:`Flask.handle_build_error` on
   exception `~werkzeug.routing.BuildError`.

#### Arguments

- `endpoint` - the endpoint of the URL (name of the function)
- `values` - the variable arguments of the URL rule
- `_external` - if set to ``True``, an absolute URL is generated. Server
  address can be changed via ``SERVER_NAME`` configuration variable which
  falls back to the `Host` header, then to the IP and port of the request.
- `_scheme` - a string specifying the desired URL scheme. The `_external`
  parameter must be set to ``True`` or a exception `ValueError` is raised. The default
  behavior uses the same scheme as the current request, or
  ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no
  request context is available. As of Werkzeug 0.10, this also can be set
  to an empty string to build protocol-relative URLs.
- `_anchor` - if provided this is added as anchor to the URL.
- `_method` - if provided this explicitly specifies an HTTP method.
