# flask.views

> Auto-generated documentation for [env.Lib.site-packages.flask.views](..\..\..\..\..\env\Lib\site-packages\flask\views.py) module.

This module provides class-based views inspired by the ones in Django.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [flask](index.md#flask) / flask.views
    - [MethodView](#methodview)
        - [MethodView().dispatch_request](#methodviewdispatch_request)
    - [MethodViewType](#methodviewtype)
    - [View](#view)
        - [View.as_view](#viewas_view)
        - [View().dispatch_request](#viewdispatch_request)

:copyright: 2010 Pallets
:license: BSD-3-Clause

## MethodView

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\views.py#L138)

```python
class MethodView(with_metaclass(MethodViewType, View)):
```

A class-based view that dispatches request methods to the corresponding
class methods. For example, if you implement a ``get`` method, it will be
used to handle ``GET`` requests. 

```python
class CounterAPI(MethodView):
    def get(self):
        return session.get('counter', 0)

    def post(self):
        session['counter'] = session.get('counter', 0) + 1
        return 'OK'

app.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))
```

### MethodView().dispatch_request

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\views.py#L154)

```python
def dispatch_request(*args, **kwargs):
```

## MethodViewType

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\views.py#L111)

```python
class MethodViewType(type):
    def __init__(name, bases, d):
```

Metaclass for :class:[MethodView](#methodview) that determines what methods the view
defines.

## View

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\views.py#L20)

```python
class View(object):
```

Alternative way to use view functions.  A subclass has to implement
:meth:`dispatch_request` which is called with the view arguments from
the URL routing system.  If attribute `methods` is provided the methods
do not have to be passed to the :meth:`~flask.Flask.add_url_rule`
method explicitly

```python
class MyView(View):
    methods = ['GET']

    def dispatch_request(self, name):
        return 'Hello %s!' % name

app.add_url_rule('/hello/<name>', view_func=MyView.as_view('myview'))
```

When you want to decorate a pluggable view you will have to either do that
when the view function is created (by wrapping the return value of
:meth:`as_view`) or you can use the attribute `decorators` attribute

```python
class SecretView(View):
    methods = ['GET']
    decorators = [superuser_required]

    def dispatch_request(self):
        ...
```

The decorators stored in the decorators list are applied one after another
when the view function is created.  Note that you can *not* use the class
based decorators since those would decorate the view class and not the
generated view function!

#### Attributes

- `methods` - : A list of methods this view can handle.: `None`
- `provide_automatic_options` - : Setting this disables or force-enables the automatic options handling.: `None`
- `decorators` - : The canonical way to decorate class-based views is to decorate the
  : return value of as_view().  However since this moves parts of the
  : logic from the class declaration to the place where it's hooked
  : into the routing system.
  :
  : You can place one or more decorators in this list and whenever the
  : view function is created the result is automatically decorated.
  :
  : .. versionadded:: 0.8: `()`

### View.as_view

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\views.py#L76)

```python
@classmethod
def as_view(name, *class_args, **class_kwargs):
```

Converts the class into an actual view function that can be used
with the routing system.  Internally this generates a function on the
fly which will instantiate the :class:[View](#view) on each request and call
the :meth:[View().dispatch_request](#viewdispatch_request) method on it.

The arguments passed to :meth:`as_view` are forwarded to the
constructor of the class.

### View().dispatch_request

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\views.py#L69)

```python
def dispatch_request():
```

Subclasses have to override this method to implement the
actual view function code.  This method is called with all
the arguments from the URL rule.
