# flask.cli

> Auto-generated documentation for [env.Lib.site-packages.flask.cli](..\..\..\..\..\env\Lib\site-packages\flask\cli.py) module.

A simple command line application to run flask apps.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [flask](index.md#flask) / flask.cli
    - [AppGroup](#appgroup)
        - [AppGroup().command](#appgroupcommand)
        - [AppGroup().group](#appgroupgroup)
    - [CertParamType](#certparamtype)
        - [CertParamType().convert](#certparamtypeconvert)
    - [DispatchingApp](#dispatchingapp)
    - [FlaskGroup](#flaskgroup)
        - [FlaskGroup().get_command](#flaskgroupget_command)
        - [FlaskGroup().list_commands](#flaskgrouplist_commands)
        - [FlaskGroup().main](#flaskgroupmain)
    - [NoAppException](#noappexception)
    - [ScriptInfo](#scriptinfo)
        - [ScriptInfo().load_app](#scriptinfoload_app)
    - [SeparatedPathType](#separatedpathtype)
        - [SeparatedPathType().convert](#separatedpathtypeconvert)
    - [call_factory](#call_factory)
    - [find_app_by_string](#find_app_by_string)
    - [find_best_app](#find_best_app)
    - [get_version](#get_version)
    - [load_dotenv](#load_dotenv)
    - [locate_app](#locate_app)
    - [main](#main)
    - [prepare_import](#prepare_import)
    - [routes_command](#routes_command)
    - [run_command](#run_command)
    - [shell_command](#shell_command)
    - [show_server_banner](#show_server_banner)
    - [with_appcontext](#with_appcontext)

:copyright: 2010 Pallets
:license: BSD-3-Clause

## AppGroup

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L431)

```python
class AppGroup(click.Group):
```

This works similar to a regular click class `click.Group` but it
changes the behavior of the :meth:`command` decorator so that it
automatically wraps the functions in :func:[with_appcontext](#with_appcontext).

Not to be confused with :class:[FlaskGroup](#flaskgroup).

### AppGroup().command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L439)

```python
def command(*args, **kwargs):
```

This works exactly like the method of the same name on a regular
class `click.Group` but it wraps callbacks in :func:[with_appcontext](#with_appcontext)
unless it's disabled by passing ``with_appcontext=False``.

### AppGroup().group

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L453)

```python
def group(*args, **kwargs):
```

This works exactly like the method of the same name on a regular
class `click.Group` but it defaults the group class to
:class:[AppGroup](#appgroup).

## CertParamType

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L686)

```python
class CertParamType(click.ParamType):
    def __init__():
```

Click option type for the ``--cert`` option. Allows either an
existing file, the string ``'adhoc'``, or an import for a
class `ssl.SSLContext` object.

### CertParamType().convert

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L697)

```python
def convert(value, param, ctx):
```

## DispatchingApp

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L292)

```python
class DispatchingApp(object):
    def __init__(loader, use_eager_loading=False):
```

Special application that dispatches to a Flask application which
is imported by name in a background thread.  If an error happens
it is recorded and shown as part of the WSGI handling which in case
of the Werkzeug debugger means that it shows up in the browser.

## FlaskGroup

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L462)

```python
class FlaskGroup(AppGroup):
    def __init__(
        add_default_commands=True,
        create_app=None,
        add_version_option=True,
        load_dotenv=True,
        set_debug_flag=True,
        **extra,
    ):
```

Special subclass of the :class:[AppGroup](#appgroup) group that supports
loading more commands from the configured Flask app.  Normally a
developer does not have to interface with this class but there are
some very advanced use cases for which it makes sense to create an
instance of this.

For information as of why this is useful see :ref:`custom-scripts`.

#### Arguments

- `add_default_commands` - if this is True then the default run and
    shell commands will be added.
- `add_version_option` - adds the ``--version`` option.
- `create_app` - an optional callback that is passed the script info and
    returns the loaded app.
- `load_dotenv` - Load the nearest :file:`.env` and :file:`.flaskenv`
    files to set environment variables. Will also change the working
    directory to the directory containing the first file found.
- `set_debug_flag` - Set the app's debug flag based on the active
    environment

#### Notes

Changed in version 1.0
    If installed, python-dotenv will be used to load environment variables
    from :file:`.env` and :file:`.flaskenv` files.

#### See also

- [AppGroup](#appgroup)

### FlaskGroup().get_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L526)

```python
def get_command(ctx, name):
```

### FlaskGroup().list_commands

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L548)

```python
def list_commands(ctx):
```

### FlaskGroup().main

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L567)

```python
def main(*args, **kwargs):
```

## NoAppException

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L48)

```python
class NoAppException(click.UsageError):
```

Raised if an application cannot be found or loaded.

## ScriptInfo

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L347)

```python
class ScriptInfo(object):
    def __init__(app_import_path=None, create_app=None, set_debug_flag=True):
```

Helper object to deal with Flask applications.  This is usually not
necessary to interface with as it's used internally in the dispatching
to click.  In future versions of Flask this object will most likely play
a bigger role.  Typically it's created automatically by the
:class:[FlaskGroup](#flaskgroup) but you can also manually create it and pass it
onwards as click object.

### ScriptInfo().load_app

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L368)

```python
def load_app():
```

Loads the Flask app (if not yet loaded) and returns it.  Calling
this multiple times will just result in the already loaded app to
be returned.

## SeparatedPathType

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L767)

```python
class SeparatedPathType(click.Path):
```

Click option type that accepts a list of values separated by the
OS's path separator (``:``, ``;`` on Windows). Each value is
validated as a class `click.Path` type.

### SeparatedPathType().convert

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L773)

```python
def convert(value, param, ctx):
```

## call_factory

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L103)

```python
def call_factory(script_info, app_factory, arguments=()):
```

Takes an app factory, a ``script_info` object and  optionally a tuple
of arguments. Checks for the existence of a script_info argument and calls
the app_factory depending on that and the arguments provided.

## find_app_by_string

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L148)

```python
def find_app_by_string(script_info, module, app_name):
```

Checks if the given string is a variable name or a function. If it is a
function, it checks for specified arguments and whether it takes a
``script_info`` argument and calls the function with the appropriate
arguments.

## find_best_app

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L52)

```python
def find_best_app(script_info, module):
```

Given a module instance this tries to find the best possible
application in the module or raises an exception.

## get_version

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L262)

```python
def get_version(ctx, param, value):
```

## load_dotenv

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L596)

```python
def load_dotenv(path=None):
```

Load "dotenv" files in order of precedence to set environment variables.

If an env var is already set it is not overwritten, so earlier files in the
list are preferred over later files.

Changes the current working directory to the location of the first file
found, with the assumption that it is in the top level project directory
and will be where the Python path should import local packages from.

This is a no-op if `python-dotenv`_ is not installed.

.. _python-dotenv: https://github.com/theskumar/python-dotenv#readme

#### Arguments

- `path` - Load the file at this location instead of searching.

#### Returns

``True`` if a file was loaded.

#### Notes

Changed in version 1.1.0
    Returns ``False`` when python-dotenv is not installed, or when
    the given path isn't a file.

Added in version 1.0

## locate_app

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L236)

```python
def locate_app(script_info, module_name, app_name, raise_if_not_found=True):
```

## main

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L965)

```python
def main(as_module=False):
```

## prepare_import

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L207)

```python
def prepare_import(path):
```

Given a filename this will try to calculate the python path, add it
to the search path and return the actual module name that is expected.

## routes_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L899)

```python
@click.command('routes', short_help='Show the routes for the app.')
@click.option(
    '--sort',
    '-s',
    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),
    default='endpoint',
    help='Method to sort routes by. "match" is the order that Flask will match routes when dispatching a request.',
)
@click.option(
    '--all-methods',
    is_flag=True,
    help='Show HEAD and OPTIONS methods.',
)
@with_appcontext
def routes_command(sort, all_methods):
```

Show all registered routes with endpoints and methods.

#### See also

- [with_appcontext](#with_appcontext)

## run_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L779)

```python
@click.command('run', short_help='Run a development server.')
@click.option(
    '--host',
    '-h',
    default='127.0.0.1',
    help='The interface to bind to.',
)
@click.option('--port', '-p', default=5000, help='The port to bind to.')
@click.option(
    '--cert',
    type=CertParamType(),
    help='Specify a certificate file to use HTTPS.',
)
@click.option(
    '--key',
    type=click.Path(exists=True, dir_okay=False, resolve_path=True),
    callback=_validate_key,
    expose_value=False,
    help='The key file to use when specifying a certificate.',
)
@click.option(
    '--reload/--no-reload',
    default=None,
    help='Enable or disable the reloader. By default the reloader is active if debug is enabled.',
)
@click.option(
    '--debugger/--no-debugger',
    default=None,
    help='Enable or disable the debugger. By default the debugger is active if debug is enabled.',
)
@click.option(
    '--eager-loading/--lazy-loader',
    default=None,
    help='Enable or disable eager loading. By default eager loading is enabled if the reloader is disabled.',
)
@click.option(
    '--with-threads/--without-threads',
    default=True,
    help='Enable or disable multithreading.',
)
@click.option(
    '--extra-files',
    default=None,
    type=SeparatedPathType(),
    help="Extra files that trigger a reload on change. Multiple paths are separated by '{}'.".format(
        os.path.pathsep,
    ),
)
@pass_script_info
def run_command(
    info,
    host,
    port,
    reload,
    debugger,
    eager_loading,
    with_threads,
    cert,
    extra_files,
):
```

Run a local development server.

This server is for development purposes only. It does not provide
the stability, security, or performance of production WSGI servers.

The reloader and debugger are enabled by default if
FLASK_ENV=development or FLASK_DEBUG=1.

#### See also

- [pass_script_info](#pass_script_info)

## shell_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L864)

```python
@click.command('shell', short_help='Run a shell in the app context.')
@with_appcontext
def shell_command():
```

Run an interactive Python shell in the context of a given
Flask application.  The application will populate the default
namespace of this shell according to it's configuration.

This is useful for executing small snippets of management code
without having to manually configure the application.

#### See also

- [with_appcontext](#with_appcontext)

## show_server_banner

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L657)

```python
def show_server_banner(env, debug, app_import_path, eager_loading):
```

Show extra startup messages the first time the server is run,
ignoring the reloader.

## with_appcontext

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask\cli.py#L416)

```python
def with_appcontext(f):
```

Wraps a callback so that it's guaranteed to be executed with the
script's application context.  If callbacks are registered directly
to the ``app.cli`` object then they are wrapped with this function
by default unless it's disabled.
