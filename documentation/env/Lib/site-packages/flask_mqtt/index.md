# Flask Mqtt

> Auto-generated documentation for [env.Lib.site-packages.flask_mqtt](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py) module.

Flask-MQTT Package.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / Flask Mqtt
    - [Mqtt](#mqtt)
        - [Mqtt().init_app](#mqttinit_app)
        - [Mqtt().on_connect](#mqtton_connect)
        - [Mqtt().on_disconnect](#mqtton_disconnect)
        - [Mqtt().on_log](#mqtton_log)
        - [Mqtt().on_message](#mqtton_message)
        - [Mqtt().on_publish](#mqtton_publish)
        - [Mqtt().on_subscribe](#mqtton_subscribe)
        - [Mqtt().on_topic](#mqtton_topic)
        - [Mqtt().on_unsubscribe](#mqtton_unsubscribe)
        - [Mqtt().publish](#mqttpublish)
        - [Mqtt().subscribe](#mqttsubscribe)
        - [Mqtt().unsubscribe](#mqttunsubscribe)
        - [Mqtt().unsubscribe_all](#mqttunsubscribe_all)

:author: Stefan Lehmann <stlm@posteo.de>
:license: MIT, see license file or https://opensource.org/licenses/MIT

#### Attributes

- `TopicQos` - : Container for topic + qos: `namedtuple('TopicQos', ['topic', 'qos'])`
- `logger` - Init logger: `logging.getLogger(__name__)`

## Mqtt

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L57)

```python
class Mqtt():
    def __init__(
        app: Flask = None,
        connect_async: bool = False,
        mqtt_logging: bool = False,
    ) -> None:
```

Main Mqtt class.

#### Arguments

- `app` - flask application object
- `connect_async` - if True then connect_aync will be used to connect to MQTT broker
- `mqtt_logging` - if True then messages from MQTT client will be logged

### Mqtt().init_app

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L106)

```python
def init_app(app: Flask) -> None:
```

Init the Flask-MQTT addon.

### Mqtt().on_connect

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L394)

```python
def on_connect() -> Callable:
```

Decorator.

Decorator to handle the event when the broker responds to a connection
request. Only the last decorated function will be called.

### Mqtt().on_disconnect

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L408)

```python
def on_disconnect() -> Callable:
```

Decorator.

Decorator to handle the event when client disconnects from broker. Only
the last decorated function will be called.

### Mqtt().on_log

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L500)

```python
def on_log() -> Callable:
```

Decorate a callback function to handle MQTT logging.

**Example Usage:**

```python
@mqtt.on_log()
def handle_logging(client, userdata, level, buf):
    print(client, userdata, level, buf)
```

### Mqtt().on_message

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L422)

```python
def on_message() -> Callable:
```

Decorator.

Decorator to handle all messages that have been subscribed and that
are not handled via the `on_message` decorator.

**Note:** Unlike as written in the paho mqtt documentation this
callback will not be called if there exists an topic-specific callback
added by the [Mqtt().on_topic](#mqtton_topic) decorator.

**Example Usage:**

```python
@mqtt.on_message()
def handle_messages(client, userdata, message):
    print('Received message on topic {}: {}'
          .format(message.topic, message.payload.decode()))
```

### Mqtt().on_publish

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L446)

```python
def on_publish() -> Callable:
```

Decorator.

Decorator to handle all messages that have been published by the
client.

**Example Usage:**

```python
@mqtt.on_publish()
def handle_publish(client, userdata, mid):
    print('Published message with mid {}.'
          .format(mid))
```

### Mqtt().on_subscribe

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L466)

```python
def on_subscribe() -> Callable:
```

Decorate a callback function to handle subscritions.

**Usage:**

```python
@mqtt.on_subscribe()
def handle_subscribe(client, userdata, mid, granted_qos):
    print('Subscription id {} granted with qos {}.'
          .format(mid, granted_qos))
```

### Mqtt().on_topic

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L245)

```python
def on_topic(topic: str) -> Callable:
```

Decorator.

Decorator to add a callback function that is called when a certain
topic has been published. The callback function is expected to have the
following form: `handle_topic(client, userdata, message)`

#### Arguments

- `topic` - a string specifying the subscription topic to
    subscribe to

The topic still needs to be subscribed via mqtt.subscribe() before the
callback function can be used to handle a certain topic. This way it is
possible to subscribe and unsubscribe during runtime.

**Example usage:**

```python
app = Flask(__name__)
mqtt = Mqtt(app)
mqtt.subscribe('home/mytopic')

@mqtt.on_topic('home/mytopic')
def handle_mytopic(client, userdata, message):
    print('Received message on topic {}: {}'
          .format(message.topic, message.payload.decode()))
```

### Mqtt().on_unsubscribe

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L483)

```python
def on_unsubscribe() -> Callable:
```

Decorate a callback funtion to handle unsubscribtions.

**Usage:**

```python
@mqtt.unsubscribe()
def handle_unsubscribe(client, userdata, mid)
    print('Unsubscribed from topic (id: {})'
          .format(mid)')
```

### Mqtt().publish

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L359)

```python
def publish(
    topic: str,
    payload: Optional[bytes] = None,
    qos: int = 0,
    retain: bool = False,
) -> Tuple[int, int]:
```

Send a message to the broker.

#### Arguments

- `topic` - the topic that the message should be published on
- `payload` - the actual message to send. If not given, or set to
                None a zero length message will be used. Passing an
                int or float will result in the payload being
                converted to a string representing that number.
                If you wish to send a true int/float, use struct.pack()
                to create the payload you require.
- `qos` - the quality of service level to use
- `retain` - if set to True, the message will be set as the
               "last known good"/retained message for the topic

#### Returns

Returns a tuple (result, mid), where result is
          MQTT_ERR_SUCCESS to indicate success or MQTT_ERR_NO_CONN
          if the client is not currently connected. mid is the message
          ID for the publish request.

### Mqtt().subscribe

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L277)

```python
def subscribe(topic: str, qos: int = 0) -> Tuple[int, int]:
```

Subscribe to a certain topic.

#### Arguments

- `topic` - a string specifying the subscription topic to
    subscribe to.
- `qos` - the desired quality of service level for the subscription.
            Defaults to 0.

#### Returns

Type: *(int, int)*
:result: (result, mid)

A topic is a UTF-8 string, which is used by the broker to filter
messages for each connected client. A topic consists of one or more
topic levels. Each topic level is separated by a forward slash
(topic level separator).

The function returns a tuple (result, mid), where result is
MQTT_ERR_SUCCESS to indicate success or (MQTT_ERR_NO_CONN, None) if the
client is not currently connected.  mid is the message ID for the
subscribe request. The mid value can be used to track the subscribe
request by checking against the mid argument in the on_subscribe()
callback if it is defined.

**Topic example:** `myhome/groundfloor/livingroom/temperature`

### Mqtt().unsubscribe

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L319)

```python
def unsubscribe(topic: str) -> Optional[Tuple[int, int]]:
```

Unsubscribe from a single topic.

#### Arguments

- `topic` - a single string that is the subscription topic to
              unsubscribe from

#### Returns

Type: *(int, int)*
:result: (result, mid)

Returns a tuple (result, mid), where result is MQTT_ERR_SUCCESS
to indicate success or (MQTT_ERR_NO_CONN, None) if the client is not
currently connected.
mid is the message ID for the unsubscribe request. The mid value can be
used to track the unsubscribe request by checking against the mid
argument in the on_unsubscribe() callback if it is defined.

### Mqtt().unsubscribe_all

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\flask_mqtt\__init__.py#L353)

```python
def unsubscribe_all() -> None:
```

Unsubscribe from all topics.
