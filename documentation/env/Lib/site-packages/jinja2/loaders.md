# Loaders

> Auto-generated documentation for [env.Lib.site-packages.jinja2.loaders](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py) module.

API and implementations for loading templates from different data
sources.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Jinja2](index.md#jinja2) / Loaders
    - [BaseLoader](#baseloader)
        - [BaseLoader().get_source](#baseloaderget_source)
        - [BaseLoader().list_templates](#baseloaderlist_templates)
        - [BaseLoader().load](#baseloaderload)
    - [ChoiceLoader](#choiceloader)
        - [ChoiceLoader().get_source](#choiceloaderget_source)
        - [ChoiceLoader().list_templates](#choiceloaderlist_templates)
        - [ChoiceLoader().load](#choiceloaderload)
    - [DictLoader](#dictloader)
        - [DictLoader().get_source](#dictloaderget_source)
        - [DictLoader().list_templates](#dictloaderlist_templates)
    - [FileSystemLoader](#filesystemloader)
        - [FileSystemLoader().get_source](#filesystemloaderget_source)
        - [FileSystemLoader().list_templates](#filesystemloaderlist_templates)
    - [FunctionLoader](#functionloader)
        - [FunctionLoader().get_source](#functionloaderget_source)
    - [ModuleLoader](#moduleloader)
        - [ModuleLoader.get_module_filename](#moduleloaderget_module_filename)
        - [ModuleLoader.get_template_key](#moduleloaderget_template_key)
        - [ModuleLoader().load](#moduleloaderload)
    - [PackageLoader](#packageloader)
        - [PackageLoader().get_source](#packageloaderget_source)
        - [PackageLoader().list_templates](#packageloaderlist_templates)
    - [PrefixLoader](#prefixloader)
        - [PrefixLoader().get_loader](#prefixloaderget_loader)
        - [PrefixLoader().get_source](#prefixloaderget_source)
        - [PrefixLoader().list_templates](#prefixloaderlist_templates)
        - [PrefixLoader().load](#prefixloaderload)
    - [split_template_path](#split_template_path)

## BaseLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L38)

```python
class BaseLoader(object):
```

Baseclass for all loaders.  Subclass this and override `get_source` to
implement a custom loading mechanism.  The environment provides a
`get_template` method that calls the loader's `load` method to get the
class `Template` object.

A very basic example for a loader that looks up templates on the file
system could look like this

```python
from jinja2 import BaseLoader, TemplateNotFound
from os.path import join, exists, getmtime

class MyLoader(BaseLoader):

    def __init__(self, path):
        self.path = path

    def get_source(self, environment, template):
        path = join(self.path, template)
        if not exists(path):
            raise TemplateNotFound(template)
        mtime = getmtime(path)
        with file(path) as f:
            source = f.read().decode('utf-8')
        return source, path, lambda: mtime == getmtime(path)
```

#### Attributes

- `has_source_access` - : if set to `False` it indicates that the loader cannot provide access
  : to the source of templates.
  :
  : .. versionadded:: 2.4: `True`

### BaseLoader().get_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L71)

```python
def get_source(environment, template):
```

Get the template source, filename and reload helper for a template.
It's passed the environment and template name and has to return a
tuple in the form ``(source, filename, uptodate)`` or raise a
`TemplateNotFound` error if it can't locate the template.

The source part of the returned tuple must be the source of the
template as unicode string or a ASCII bytestring.  The filename should
be the name of the file on the filesystem if it was loaded from there,
otherwise `None`.  The filename is used by python for the tracebacks
if no loader extension is used.

The last item in the tuple is the `uptodate` function.  If auto
reloading is enabled it's always called to check if the template
changed.  No arguments are passed so the function must store the
old state somewhere (for example in a closure).  If it returns `False`
the template will be reloaded.

### BaseLoader().list_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L95)

```python
def list_templates():
```

Iterates over all templates.  If the loader does not support that
it should raise a exception `TypeError` which is the default behavior.

### BaseLoader().load

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L101)

```python
@internalcode
def load(environment, name, globals=None):
```

Loads a template.  This method looks up the template in the cache
or loads one by calling :meth:[BaseLoader().get_source](#baseloaderget_source).  Subclasses should not
override this method as loaders working on collections of other
loaders (such as :class:[PrefixLoader](#prefixloader) or :class:[ChoiceLoader](#choiceloader))
will not call this method but [BaseLoader().get_source](#baseloaderget_source) directly.

## ChoiceLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L397)

```python
class ChoiceLoader(BaseLoader):
    def __init__(loaders):
```

This loader works like the [PrefixLoader](#prefixloader) just that no prefix is
specified.  If a template could not be found by one loader the next one
is tried.

```python
>>> loader = ChoiceLoader([
...     FileSystemLoader('/path/to/user/templates'),
...     FileSystemLoader('/path/to/system/templates')
... ])
```

This is useful if you want to allow users to override builtin templates
from a different location.

#### See also

- [BaseLoader](#baseloader)

### ChoiceLoader().get_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L414)

```python
def get_source(environment, template):
```

### ChoiceLoader().list_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L431)

```python
def list_templates():
```

### ChoiceLoader().load

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L422)

```python
@internalcode
def load(environment, name, globals=None):
```

## DictLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L291)

```python
class DictLoader(BaseLoader):
    def __init__(mapping):
```

Loads a template from a python dict.  It's passed a dict of unicode
strings bound to template names.  This loader is useful for unittesting:

```python
>>> loader = DictLoader({'index.html': 'source here'})
```

Because auto reloading is rarely useful this is disabled per default.

#### See also

- [BaseLoader](#baseloader)

### DictLoader().get_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L303)

```python
def get_source(environment, template):
```

### DictLoader().list_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L309)

```python
def list_templates():
```

## FileSystemLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L141)

```python
class FileSystemLoader(BaseLoader):
    def __init__(searchpath, encoding='utf-8', followlinks=False):
```

Loads templates from the file system.  This loader can find templates
in folders on the file system and is the preferred way to load them.

The loader takes the path to the templates as string, or if multiple
locations are wanted a list of them which is then looked up in the
given order

```python
>>> loader = FileSystemLoader('/path/to/templates')
>>> loader = FileSystemLoader(['/path/to/templates', '/other/path'])
```

Per default the template encoding is ``'utf-8'`` which can be changed
by setting the `encoding` parameter to something else.

To follow symbolic links, set the *followlinks* parameter to ``True``

```python
>>> loader = FileSystemLoader('/path/to/templates', followlinks=True)
```

#### Notes

Changed in version 2.8
   The ``followlinks`` parameter was added.

#### See also

- [BaseLoader](#baseloader)

### FileSystemLoader().get_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L176)

```python
def get_source(environment, template):
```

### FileSystemLoader().list_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L199)

```python
def list_templates():
```

## FunctionLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L313)

```python
class FunctionLoader(BaseLoader):
    def __init__(load_func):
```

A loader that is passed a function which does the loading.  The
function receives the name of the template and has to return either
an unicode string with the template source, a tuple in the form ``(source,
filename, uptodatefunc)`` or `None` if the template does not exist.

```python
>>> def load_template(name):
...     if name == 'index.html':
...         return '...'
...
>>> loader = FunctionLoader(load_template)
```

The `uptodatefunc` is a function that is called if autoreload is enabled
and has to return `True` if the template is still up to date.  For more
details have a look at :meth:[BaseLoader().get_source](#baseloaderget_source) which has the same
return value.

#### See also

- [BaseLoader](#baseloader)

### FunctionLoader().get_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L334)

```python
def get_source(environment, template):
```

## ModuleLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L442)

```python
class ModuleLoader(BaseLoader):
    def __init__(path):
```

This loader loads templates from precompiled templates.

Example usage:

```python
>>> loader = ChoiceLoader([
...     ModuleLoader('/path/to/compiled/templates'),
...     FileSystemLoader('/path/to/templates')
... ])
```

Templates can be precompiled with :meth:`Environment.compile_templates`.

#### See also

- [BaseLoader](#baseloader)

### ModuleLoader.get_module_filename

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L483)

```python
@staticmethod
def get_module_filename(name):
```

### ModuleLoader.get_template_key

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L479)

```python
@staticmethod
def get_template_key(name):
```

### ModuleLoader().load

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L487)

```python
@internalcode
def load(environment, name, globals=None):
```

## PackageLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L217)

```python
class PackageLoader(BaseLoader):
    def __init__(package_name, package_path='templates', encoding='utf-8'):
```

Load templates from python eggs or packages.  It is constructed with
the name of the python package and the path to the templates in that
package

```python
loader = PackageLoader('mypackage', 'views')
```

If the package path is not given, ``'templates'`` is assumed.

Per default the template encoding is ``'utf-8'`` which can be changed
by setting the `encoding` parameter to something else.  Due to the nature
of eggs it's only possible to reload templates if the package was loaded
from the file system and not a zip file.

#### See also

- [BaseLoader](#baseloader)

### PackageLoader().get_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L244)

```python
def get_source(environment, template):
```

### PackageLoader().list_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L266)

```python
def list_templates():
```

## PrefixLoader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L343)

```python
class PrefixLoader(BaseLoader):
    def __init__(mapping, delimiter='/'):
```

A loader that is passed a dict of loaders where each loader is bound
to a prefix.  The prefix is delimited from the template by a slash per
default, which can be changed by setting the `delimiter` argument to
something else

```python
loader = PrefixLoader({
    'app1':     PackageLoader('mypackage.app1'),
    'app2':     PackageLoader('mypackage.app2')
})
```

By loading ``'app1/index.html'`` the file from the app1 package is loaded,
by loading ``'app2/index.html'`` the file from the second.

#### See also

- [BaseLoader](#baseloader)

### PrefixLoader().get_loader

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L362)

```python
def get_loader(template):
```

### PrefixLoader().get_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L370)

```python
def get_source(environment, template):
```

### PrefixLoader().list_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L389)

```python
def list_templates():
```

### PrefixLoader().load

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L379)

```python
@internalcode
def load(environment, name, globals=None):
```

## split_template_path

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\loaders.py#L21)

```python
def split_template_path(template):
```

Split a path into segments and perform a sanity check.  If it detects
'..' in the path it will raise a `TemplateNotFound` error.
