# Environment

> Auto-generated documentation for [env.Lib.site-packages.jinja2.environment](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py) module.

Classes for managing templates and their runtime and compile time
options.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Jinja2](index.md#jinja2) / Environment
    - [Environment](#environment)
        - [Environment().add_extension](#environmentadd_extension)
        - [Environment().call_filter](#environmentcall_filter)
        - [Environment().call_test](#environmentcall_test)
        - [Environment().compile](#environmentcompile)
        - [Environment().compile_expression](#environmentcompile_expression)
        - [Environment().compile_templates](#environmentcompile_templates)
        - [Environment().extend](#environmentextend)
        - [Environment().from_string](#environmentfrom_string)
        - [Environment().get_or_select_template](#environmentget_or_select_template)
        - [Environment().get_template](#environmentget_template)
        - [Environment().getattr](#environmentgetattr)
        - [Environment().getitem](#environmentgetitem)
        - [Environment().handle_exception](#environmenthandle_exception)
        - [Environment().iter_extensions](#environmentiter_extensions)
        - [Environment().join_path](#environmentjoin_path)
        - [Environment().lex](#environmentlex)
        - [Environment().list_templates](#environmentlist_templates)
        - [Environment().make_globals](#environmentmake_globals)
        - [Environment().overlay](#environmentoverlay)
        - [Environment().parse](#environmentparse)
        - [Environment().preprocess](#environmentpreprocess)
        - [Environment().select_template](#environmentselect_template)
    - [Template](#template)
        - [Template().debug_info](#templatedebug_info)
        - [Template.from_code](#templatefrom_code)
        - [Template.from_module_dict](#templatefrom_module_dict)
        - [Template().generate](#templategenerate)
        - [Template().generate_async](#templategenerate_async)
        - [Template().get_corresponding_lineno](#templateget_corresponding_lineno)
        - [Template().is_up_to_date](#templateis_up_to_date)
        - [Template().make_module](#templatemake_module)
        - [Template().make_module_async](#templatemake_module_async)
        - [Template().module](#templatemodule)
        - [Template().new_context](#templatenew_context)
        - [Template().render](#templaterender)
        - [Template().render_async](#templaterender_async)
        - [Template().stream](#templatestream)
    - [TemplateExpression](#templateexpression)
    - [TemplateModule](#templatemodule)
    - [TemplateStream](#templatestream)
        - [TemplateStream().disable_buffering](#templatestreamdisable_buffering)
        - [TemplateStream().dump](#templatestreamdump)
        - [TemplateStream().enable_buffering](#templatestreamenable_buffering)
    - [copy_cache](#copy_cache)
    - [create_cache](#create_cache)
    - [fail_for_missing_callable](#fail_for_missing_callable)
    - [get_spontaneous_environment](#get_spontaneous_environment)
    - [load_extensions](#load_extensions)

## Environment

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L141)

```python
class Environment(object):
    def __init__(
        block_start_string=BLOCK_START_STRING,
        block_end_string=BLOCK_END_STRING,
        variable_start_string=VARIABLE_START_STRING,
        variable_end_string=VARIABLE_END_STRING,
        comment_start_string=COMMENT_START_STRING,
        comment_end_string=COMMENT_END_STRING,
        line_statement_prefix=LINE_STATEMENT_PREFIX,
        line_comment_prefix=LINE_COMMENT_PREFIX,
        trim_blocks=TRIM_BLOCKS,
        lstrip_blocks=LSTRIP_BLOCKS,
        newline_sequence=NEWLINE_SEQUENCE,
        keep_trailing_newline=KEEP_TRAILING_NEWLINE,
        extensions=(),
        optimized=True,
        undefined=Undefined,
        finalize=None,
        autoescape=False,
        loader=None,
        cache_size=400,
        auto_reload=True,
        bytecode_cache=None,
        enable_async=False,
    ):
```

The core component of Jinja is the [Environment](#environment).  It contains
important shared variables like configuration, filters, tests,
globals and others.  Instances of this class may be modified if
they are not shared and if no template was loaded so far.
Modifications on environments after the first template was loaded
will lead to surprising effects and undefined behavior.

Here are the possible initialization parameters:

`block_start_string`
    The string marking the beginning of a block.  Defaults to ``'{%'``.

`block_end_string`
    The string marking the end of a block.  Defaults to ``'%}'``.

`variable_start_string`
    The string marking the beginning of a print statement.
    Defaults to ``'{{'``.

`variable_end_string`
    The string marking the end of a print statement.  Defaults to
    ``'}}'``.

`comment_start_string`
    The string marking the beginning of a comment.  Defaults to ``'{#'``.

`comment_end_string`
    The string marking the end of a comment.  Defaults to ``'#}'``.

`line_statement_prefix`
    If given and a string, this will be used as prefix for line based
    statements.  See also :ref:`line-statements`.

`line_comment_prefix`
    If given and a string, this will be used as prefix for line based
    comments.  See also :ref:`line-statements`.

#### Notes

Added in version 2.2

`trim_blocks`
    If this is set to ``True`` the first newline after a block is
    removed (block, not variable tag!).  Defaults to `False`.

`lstrip_blocks`
    If this is set to ``True`` leading spaces and tabs are stripped
    from the start of a line to a block.  Defaults to `False`.

`newline_sequence`
    The sequence that starts a newline.  Must be one of ``'\r'``,
    ``'\n'`` or ``'\r\n'``.  The default is ``'\n'`` which is a
    useful default for Linux and OS X systems as well as web
    applications.

`keep_trailing_newline`
    Preserve the trailing newline when rendering templates.
    The default is ``False``, which causes a single newline,
    if present, to be stripped from the end of the template.

Added in version 2.7

`extensions`
    List of Jinja extensions to use.  This can either be import paths
    as strings or extension classes.  For more information have a
    look at :ref:`the extensions documentation <jinja-extensions>`.

`optimized`
    should the optimizer be enabled?  Default is ``True``.

`undefined`
    class `Undefined` or a subclass of it that is used to represent
    undefined values in the template.

`finalize`
    A callable that can be used to process the result of a variable
    expression before it is output.  For example one can convert
    ``None`` implicitly into an empty string here.

`autoescape`
    If set to ``True`` the XML/HTML autoescaping feature is enabled by
    default.  For more details about autoescaping see
    class `markupsafe.Markup`.  As of Jinja 2.4 this can also
    be a callable that is passed the template name and has to
    return ``True`` or ``False`` depending on autoescape should be
    enabled by default.

Changed in version 2.4
   `autoescape` can now be a function

`loader`
    The template loader for this environment.

`cache_size`
    The size of the cache.  Per default this is ``400`` which means
    that if more than 400 templates are loaded the loader will clean
    out the least recently used template.  If the cache size is set to
    ``0`` templates are recompiled all the time, if the cache size is
    ``-1`` the cache will not be cleaned.

Changed in version 2.8
   The cache size was increased to 400 from a low 50.

`auto_reload`
    Some loaders load templates from locations where the template
    sources may change (ie: file system or database).  If
    ``auto_reload`` is set to ``True`` (default) every time a template is
    requested the loader checks if the source changed and if yes, it
    will reload the template.  For higher performance it's possible to
    disable that.

`bytecode_cache`
    If set to a bytecode cache object, this object will provide a
    cache for the internal Jinja bytecode so that templates don't
    have to be parsed if they were not changed.

See :ref:`bytecode-cache` for more information.

`enable_async`
    If set to true this enables async template execution which allows
    you to take advantage of newer Python features.  This requires
    Python 3.6 or later.

#### Attributes

- `sandboxed` - : if this environment is sandboxed.  Modifying this variable won't make
  : the environment sandboxed though.  For a real sandboxed environment
  : have a look at jinja2.sandbox.  This flag alone controls the code
  : generation by the compiler.: `False`
- `overlayed` - : True if the environment is just an overlay: `False`
- `linked_to` - : the environment this environment is linked to if it is an overlay: `None`
- `shared` - : shared environments have this set to `True`.  A shared environment
  : must not be modified: `False`
- `code_generator_class` - : the class that is used for code generation.  See
  : :class:`~jinja2.compiler.CodeGenerator` for more information.: `CodeGenerator`
- `context_class` - : the context class thatis used for templates.  See
  : :class:`~jinja2.runtime.Context` for more information.: `Context`

### Environment().add_extension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L369)

```python
def add_extension(extension):
```

Adds an extension after the environment was created.

#### Notes

Added in version 2.5

### Environment().call_filter

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L479)

```python
def call_filter(
    name,
    value,
    args=None,
    kwargs=None,
    context=None,
    eval_ctx=None,
):
```

Invokes a filter on a value the same way the compiler does it.

Note that on Python 3 this might return a coroutine in case the
filter is running from an environment in async mode and the filter
supports async execution.  It's your responsibility to await this
if needed.

#### Notes

Added in version 2.7

### Environment().call_test

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L512)

```python
def call_test(name, value, args=None, kwargs=None):
```

Invokes a test on a value the same way the compiler does it.

#### Notes

Added in version 2.7

### Environment().compile

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L603)

```python
@internalcode
def compile(source, name=None, filename=None, raw=False, defer_init=False):
```

Compile a node or template source code.  The `name` parameter is
the load name of the template after it was joined using
:meth:[Environment().join_path](#environmentjoin_path) if necessary, not the filename on the file system.
the `filename` parameter is the estimated filename of the template on
the file system.  If the template came from a database or memory this
can be omitted.

The return value of this method is a python code object.  If the `raw`
parameter is `True` the return value will be a string with python
code equivalent to the bytecode returned otherwise.  This method is
mainly used internally.

`defer_init` is use internally to aid the module code generator.  This
causes the generated code to be able to import without the global
environment variable to be set.

#### Notes

Added in version 2.4
   `defer_init` parameter added.

### Environment().compile_expression

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L640)

```python
def compile_expression(source, undefined_to_none=True):
```

A handy helper method that returns a callable that accepts keyword
arguments that appear as variables in the expression.  If called it
returns the result of the expression.

This is useful if applications want to use the same rules as Jinja
in template "configuration files" or similar situations.

Example usage:

```python
>>> env = Environment()
>>> expr = env.compile_expression('foo == 42')
>>> expr(foo=23)
False
>>> expr(foo=42)
True
```

Per default the return value is converted to `None` if the
expression returns an undefined value.  This can be changed
by setting `undefined_to_none` to `False`.

```python
>>> env.compile_expression('var')() is None
True
>>> env.compile_expression('var', undefined_to_none=False)()
Undefined
```

#### Notes

Added in version 2.1

### Environment().compile_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L684)

```python
def compile_templates(
    target,
    extensions=None,
    filter_func=None,
    zip='deflated',
    log_function=None,
    ignore_errors=True,
    py_compile=False,
):
```

Finds all the templates the loader can find, compiles them
and stores them in `target`.  If `zip` is `None`, instead of in a
zipfile, the templates will be stored in a directory.
By default a deflate zip algorithm is used. To switch to
the stored algorithm, `zip` can be set to ``'stored'``.

`extensions` and `filter_func` are passed to :meth:[Environment().list_templates](#environmentlist_templates).
Each template returned will be compiled to the target folder or
zipfile.

By default template compilation errors are ignored.  In case a
log function is provided, errors are logged.  If you want template
syntax errors to abort the compilation you can set `ignore_errors`
to `False` and you will get an exception on syntax errors.

If `py_compile` is set to `True` .pyc files will be written to the
target instead of standard .py files.  This flag does not do anything
on pypy and Python 3 where pyc files are not picked up by itself and
don't give much benefit.

#### Notes

Added in version 2.4

### Environment().extend

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L376)

```python
def extend(**attributes):
```

Add the items to the instance of the environment if they do not exist
yet.  This is used by :ref:`extensions <writing-extensions>` to register
callbacks and configuration values without breaking inheritance.

### Environment().from_string

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L935)

```python
def from_string(source, globals=None, template_class=None):
```

Load a template from a string.  This parses the source given and
returns a :class:[Template](#template) object.

### Environment().get_or_select_template

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L921)

```python
@internalcode
def get_or_select_template(template_name_or_list, parent=None, globals=None):
```

Does a typecheck and dispatches to :meth:[Environment().select_template](#environmentselect_template)
if an iterable of template names is given, otherwise to
:meth:[Environment().get_template](#environmentget_template).

#### Notes

Added in version 2.3

### Environment().get_template

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L862)

```python
@internalcode
def get_template(name, parent=None, globals=None):
```

Load a template from the loader.  If a loader is configured this
method asks the loader for the template and returns a :class:[Template](#template).
If the `parent` parameter is not `None`, :meth:[Environment().join_path](#environmentjoin_path) is called
to get the real template name before loading.

The `globals` parameter can be used to provide template wide globals.
These variables are available in the context at render time.

If the template does not exist a exception `TemplateNotFound` exception is
raised.

#### Notes

Changed in version 2.4
   If `name` is a :class:[Template](#template) object it is returned from the
   function unchanged.

### Environment().getattr

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L466)

```python
def getattr(obj, attribute):
```

Get an item or attribute of an object but prefer the attribute.
Unlike :meth:[Environment().getitem](#environmentgetitem) the attribute *must* be a bytestring.

### Environment().getitem

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L449)

```python
def getitem(obj, argument):
```

Get an item or attribute of an object but prefer the item.

### Environment().handle_exception

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L826)

```python
def handle_exception(source=None):
```

Exception handling helper.  This is used internally to either raise
rewritten exceptions or return a rendered traceback for the template.

### Environment().iter_extensions

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L445)

```python
def iter_extensions():
```

Iterates over the extensions by priority.

### Environment().join_path

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L834)

```python
def join_path(template, parent):
```

Join a template with the parent.  By default all the lookups are
relative to the loader root so this method returns the `template`
parameter unchanged, but if the paths should be relative to the
parent template, this function can be used to calculate the real
template name.

Subclasses may override this method and implement template path
joining here.

### Environment().lex

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L541)

```python
def lex(source, name=None, filename=None):
```

Lex the given sourcecode and return a generator that yields
tokens as tuples in the form ``(lineno, token_type, value)``.
This can be useful for :ref:`extension development <writing-extensions>`
and debugging templates.

This does not perform preprocessing.  If you want the preprocessing
of the extensions to be applied you have to filter source through
the :meth:[Environment().preprocess](#environmentpreprocess) method.

### Environment().list_templates

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L794)

```python
def list_templates(extensions=None, filter_func=None):
```

Returns a list of templates for this environment.  This requires
that the loader supports the loader's
:meth:`~BaseLoader.list_templates` method.

If there are other files in the template folder besides the
actual templates, the returned list can be filtered.  There are two
ways: either `extensions` is set to a list of file extensions for
templates, or a `filter_func` can be provided which is a callable that
is passed a template name and should return `True` if it should end up
in the result list.

If the loader does not support that, a exception `TypeError` is raised.

#### Notes

Added in version 2.4

### Environment().make_globals

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L943)

```python
def make_globals(d):
```

Return a dict for the globals.

### Environment().overlay

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L385)

```python
def overlay(
    block_start_string=missing,
    block_end_string=missing,
    variable_start_string=missing,
    variable_end_string=missing,
    comment_start_string=missing,
    comment_end_string=missing,
    line_statement_prefix=missing,
    line_comment_prefix=missing,
    trim_blocks=missing,
    lstrip_blocks=missing,
    extensions=missing,
    optimized=missing,
    undefined=missing,
    finalize=missing,
    autoescape=missing,
    loader=missing,
    cache_size=missing,
    auto_reload=missing,
    bytecode_cache=missing,
):
```

Create a new overlay environment that shares all the data with the
current environment except for cache and the overridden attributes.
Extensions cannot be removed for an overlayed environment.  An overlayed
environment automatically gets all the extensions of the environment it
is linked to plus optional extra extensions.

Creating overlays should happen after the initial environment was set
up completely.  Not all attributes are truly linked, some are just
copied over so modifications on the original environment may not shine
through.

### Environment().parse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L522)

```python
@internalcode
def parse(source, name=None, filename=None):
```

Parse the sourcecode and return the abstract syntax tree.  This
tree of nodes is used by the compiler to convert the template into
executable source- or bytecode.  This is useful for debugging or to
extract information from templates.

If you are :ref:`developing Jinja extensions <writing-extensions>`
this gives you a good overview of the node tree generated.

### Environment().preprocess

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L557)

```python
def preprocess(source, name=None, filename=None):
```

Preprocesses the source with all extensions.  This is automatically
called for all parsing and compiling methods but *not* for :meth:[Environment().lex](#environmentlex)
because there you usually only want the actual source tokenized.

### Environment().select_template

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L885)

```python
@internalcode
def select_template(names, parent=None, globals=None):
```

Works like :meth:[Environment().get_template](#environmentget_template) but tries a number of templates
before it fails.  If it cannot find any of the templates, it will
raise a exception `TemplatesNotFound` exception.

#### Notes

Changed in version 2.11
    If names is class `Undefined`, an exception `UndefinedError` is
    raised instead. If no templates were found and names
    contains class `Undefined`, the message is more helpful.

Changed in version 2.4
   If `names` contains a :class:[Template](#template) object it is returned
   from the function unchanged.

Added in version 2.3

## Template

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L950)

```python
class Template(object):
```

The central template object.  This class represents a compiled template
and is used to evaluate it.

Normally the template object is generated from an :class:[Environment](#environment) but
it also has a constructor that makes it possible to create a template
instance directly using the constructor.  It takes the same arguments as
the environment constructor but it's not possible to specify a loader.

Every template object has a few methods and members that are guaranteed
to exist.  However it's important that a template object should be
considered immutable.  Modifications on the object are not supported.

Template objects created from the constructor rather than an environment
do have an `environment` attribute that points to a temporary environment
that is probably shared with other templates created with the constructor
and compatible settings.

```python
>>> template = Template('Hello {{ name }}!')
>>> template.render(name='John Doe') == u'Hello John Doe!'
True
>>> stream = template.stream(name='John Doe')
>>> next(stream) == u'Hello John Doe!'
True
>>> next(stream)
Traceback (most recent call last):
    ...
StopIteration

#### Attributes

- `environment_class` - : Type of environment to create when creating a template directly
  : rather than through an existing environment.: `Environment`

### Template().debug_info

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1207)

```python
@property
def debug_info():
```

The debug info mapping.

### Template.from_code

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1033)

```python
@classmethod
def from_code(environment, code, globals, uptodate=None):
```

Creates a template object from compiled code and the globals.  This
is used by the loaders and environment to create a template object.

### Template.from_module_dict

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1044)

```python
@classmethod
def from_module_dict(environment, module_dict, globals):
```

Creates a template object from a module.  This is used by the
module loader to create a template object.

#### Notes

Added in version 2.4

### Template().generate

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1112)

```python
def generate(*args, **kwargs):
```

For very large templates it can be useful to not render the whole
template at once but evaluate each statement after another and yield
piece for piece.  This method basically does exactly that and returns
a generator that yields one item after another as unicode strings.

It accepts the same arguments as :meth:[Template().render](#templaterender).

### Template().generate_async

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1127)

```python
def generate_async(*args, **kwargs):
```

An async version of :meth:[Template().generate](#templategenerate).  Works very similarly but
returns an async iterator instead.

### Template().get_corresponding_lineno

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1191)

```python
def get_corresponding_lineno(lineno):
```

Return the source line number of a line number in the
generated bytecode as they are not in sync.

### Template().is_up_to_date

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1200)

```python
@property
def is_up_to_date():
```

If this variable is `False` there is a newer version available.

### Template().make_module

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1148)

```python
def make_module(vars=None, shared=False, locals=None):
```

This method works like the :attr:[Template().module](#templatemodule) attribute when called
without arguments but it will evaluate the template on every call
rather than caching it.  It's also possible to provide
a dict which is then used as context.  The arguments are the same
as for the :meth:[Template().new_context](#templatenew_context) method.

### Template().make_module_async

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1157)

```python
def make_module_async(vars=None, shared=False, locals=None):
```

As template module creation can invoke template code for
asynchronous executions this method must be used instead of the
normal :meth:[Template().make_module](#templatemake_module) one.  Likewise the module attribute
becomes unavailable in async mode.

### Template().module

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1175)

```python
@property
def module():
```

The template as module.  This is used for imports in the
template runtime but is also useful if one wants to access
exported template variables from the Python layer:

```python
>>> t = Template('{% macro foo() %}42{% endmacro %}23')
>>> str(t.module)
'23'
>>> t.module.foo() == u'42'
True
```

This attribute is not available if async mode is enabled.

### Template().new_context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1136)

```python
def new_context(vars=None, shared=False, locals=None):
```

Create a new class `Context` for this template.  The vars
provided will be passed to the template.  Per default the globals
are added to the context.  If shared is set to `True` the data
is passed as is to the context without adding the globals.

`locals` can be a dict of local variables for internal usage.

### Template().render

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1076)

```python
def render(*args, **kwargs):
```

This method accepts the same arguments as the `dict` constructor:
A dict, a dict subclass or some keyword arguments.  If no arguments
are given the context will be empty.  These two calls do the same

```python
template.render(knights='that say nih')
template.render({'knights': 'that say nih'})
```

This will return the rendered template as unicode string.

### Template().render_async

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1092)

```python
def render_async(*args, **kwargs):
```

This works similar to :meth:[Template().render](#templaterender) but returns a coroutine
that when awaited returns the entire rendered template string.  This
requires the async feature to be enabled.

Example usage

```python
await template.render_async(knights='that say nih; asynchronously')
```

### Template().stream

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1106)

```python
def stream(*args, **kwargs):
```

Works exactly like :meth:[Template().generate](#templategenerate) but returns a
:class:[TemplateStream](#templatestream).

## TemplateExpression

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1257)

```python
class TemplateExpression(object):
    def __init__(template, undefined_to_none):
```

The :meth:`jinja2.Environment.compile_expression` method returns an
instance of this object.  It encapsulates the expression-like access
to the template with an expression it wraps.

## TemplateModule

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1222)

```python
implements_to_string
class TemplateModule(object):
    def __init__(template, context, body_stream=None):
```

Represents an imported template.  All the exported names of the
template are available as attributes on this object.  Additionally
converting it into an unicode- or bytestrings renders the contents.

## TemplateStream

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1276)

```python
implements_iterator
class TemplateStream(object):
    def __init__(gen):
```

A template stream works pretty much like an ordinary python generator
but it can buffer multiple items to reduce the number of total iterations.
Per default the output is unbuffered which means that for every unbuffered
instruction in the template one unicode string is yielded.

If buffering is enabled with a buffer size of 5, five items are combined
into a new unicode string.  This is mainly useful if you are streaming
big templates to a client via WSGI which flushes after each iteration.

### TemplateStream().disable_buffering

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1321)

```python
def disable_buffering():
```

Disable the output buffering.

### TemplateStream().dump

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1292)

```python
def dump(fp, encoding=None, errors='strict'):
```

Dump the complete stream into a file or file-like object.
Per default unicode strings are written, if you want to encode
before writing specify an `encoding`.

Example usage

```python
Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')
```

### TemplateStream().enable_buffering

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L1345)

```python
def enable_buffering(size=5):
```

Enable buffering.  Buffer `size` items before yielding them.

## copy_cache

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L92)

```python
def copy_cache(cache):
```

Create an empty copy of the given cache.

## create_cache

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L83)

```python
def create_cache(size):
```

Return the cache class for the given size.

## fail_for_missing_callable

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L113)

```python
def fail_for_missing_callable(string, name):
```

## get_spontaneous_environment

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L65)

```python
def get_spontaneous_environment(cls, *args):
```

Return a new spontaneous environment. A spontaneous environment
is used for templates created directly rather than through an
existing environment.

#### Arguments

- `cls` - Environment class to create.
- `args` - Positional arguments passed to environment.

## load_extensions

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\environment.py#L101)

```python
def load_extensions(environment, extensions):
```

Load the extensions from the list and bind it to the environment.
Returns a dict of instantiated environments.
