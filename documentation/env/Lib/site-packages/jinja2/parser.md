# Parser

> Auto-generated documentation for [env.Lib.site-packages.jinja2.parser](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py) module.

Parse tokens from the lexer into nodes for the compiler.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Jinja2](index.md#jinja2) / Parser
    - [Parser](#parser)
        - [Parser().fail](#parserfail)
        - [Parser().fail_eof](#parserfail_eof)
        - [Parser().fail_unknown_tag](#parserfail_unknown_tag)
        - [Parser().free_identifier](#parserfree_identifier)
        - [Parser().is_tuple_end](#parseris_tuple_end)
        - [Parser().parse](#parserparse)
        - [Parser().parse_and](#parserparse_and)
        - [Parser().parse_assign_target](#parserparse_assign_target)
        - [Parser().parse_autoescape](#parserparse_autoescape)
        - [Parser().parse_block](#parserparse_block)
        - [Parser().parse_call](#parserparse_call)
        - [Parser().parse_call_block](#parserparse_call_block)
        - [Parser().parse_compare](#parserparse_compare)
        - [Parser().parse_concat](#parserparse_concat)
        - [Parser().parse_condexpr](#parserparse_condexpr)
        - [Parser().parse_dict](#parserparse_dict)
        - [Parser().parse_expression](#parserparse_expression)
        - [Parser().parse_extends](#parserparse_extends)
        - [Parser().parse_filter](#parserparse_filter)
        - [Parser().parse_filter_block](#parserparse_filter_block)
        - [Parser().parse_filter_expr](#parserparse_filter_expr)
        - [Parser().parse_for](#parserparse_for)
        - [Parser().parse_from](#parserparse_from)
        - [Parser().parse_if](#parserparse_if)
        - [Parser().parse_import](#parserparse_import)
        - [Parser().parse_import_context](#parserparse_import_context)
        - [Parser().parse_include](#parserparse_include)
        - [Parser().parse_list](#parserparse_list)
        - [Parser().parse_macro](#parserparse_macro)
        - [Parser().parse_math1](#parserparse_math1)
        - [Parser().parse_math2](#parserparse_math2)
        - [Parser().parse_not](#parserparse_not)
        - [Parser().parse_or](#parserparse_or)
        - [Parser().parse_postfix](#parserparse_postfix)
        - [Parser().parse_pow](#parserparse_pow)
        - [Parser().parse_primary](#parserparse_primary)
        - [Parser().parse_print](#parserparse_print)
        - [Parser().parse_set](#parserparse_set)
        - [Parser().parse_signature](#parserparse_signature)
        - [Parser().parse_statement](#parserparse_statement)
        - [Parser().parse_statements](#parserparse_statements)
        - [Parser().parse_subscribed](#parserparse_subscribed)
        - [Parser().parse_subscript](#parserparse_subscript)
        - [Parser().parse_test](#parserparse_test)
        - [Parser().parse_tuple](#parserparse_tuple)
        - [Parser().parse_unary](#parserparse_unary)
        - [Parser().parse_with](#parserparse_with)
        - [Parser().subparse](#parsersubparse)

## Parser

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L38)

```python
class Parser(object):
    def __init__(environment, source, name=None, filename=None, state=None):
```

This is the central parsing class Jinja uses.  It's passed to
extensions and can be used to parse expressions or statements.

### Parser().fail

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L57)

```python
def fail(msg, lineno=None, exc=TemplateSyntaxError):
```

Convenience method that raises `exc` with the message, passed
line number or last line number as well as the current name and
filename.

### Parser().fail_eof

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L110)

```python
def fail_eof(end_tokens=None, lineno=None):
```

Like fail_unknown_tag but for end of template situations.

### Parser().fail_unknown_tag

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L103)

```python
def fail_unknown_tag(name, lineno=None):
```

Called if the parser encounters an unknown tag.  Tries to fail
with a human readable error message that could help to identify
the problem.

### Parser().free_identifier

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L125)

```python
def free_identifier(lineno=None):
```

Return a new free identifier as class `jinja2.nodes.InternalName`.

### Parser().is_tuple_end

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L117)

```python
def is_tuple_end(extra_end_rules=None):
```

Are we at the end of a tuple?

### Parser().parse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L935)

```python
def parse():
```

Parse the whole template into a `Template` node.

### Parser().parse_and

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L473)

```python
def parse_and():
```

### Parser().parse_assign_target

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L405)

```python
def parse_assign_target(
    with_tuple=True,
    name_only=False,
    extra_end_rules=None,
    with_namespace=False,
):
```

Parse an assignment target.  As Jinja allows assignments to
tuples, this function can parse all allowed assignment targets.  Per
default assignments to tuples are parsed, that can be disable however
by setting `with_tuple` to `False`.  If only assignments to names are
wanted `name_only` can be set to `True`.  The `extra_end_rules`
parameter is forwarded to the tuple parsing function.  If
`with_namespace` is enabled, a namespace assignment may be parsed.

### Parser().parse_autoescape

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L252)

```python
def parse_autoescape():
```

### Parser().parse_block

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L258)

```python
def parse_block():
```

### Parser().parse_call

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L780)

```python
def parse_call(node):
```

### Parser().parse_call_block

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L369)

```python
def parse_call_block():
```

### Parser().parse_compare

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L488)

```python
def parse_compare():
```

### Parser().parse_concat

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L522)

```python
def parse_concat():
```

### Parser().parse_condexpr

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L451)

```python
def parse_condexpr():
```

### Parser().parse_dict

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L679)

```python
def parse_dict():
```

### Parser().parse_expression

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L442)

```python
def parse_expression(with_condexpr=True):
```

Parse an expression.  Per default all expressions are parsed, if
the optional `with_condexpr` parameter is set to `False` conditional
expressions are not parsed.

### Parser().parse_extends

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L277)

```python
def parse_extends():
```

### Parser().parse_filter

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L828)

```python
def parse_filter(node, start_inline=False):
```

### Parser().parse_filter_block

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L383)

```python
def parse_filter_block():
```

### Parser().parse_filter_expr

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L707)

```python
def parse_filter_expr(node):
```

### Parser().parse_for

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L198)

```python
def parse_for():
```

Parse a for loop.

### Parser().parse_from

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L311)

```python
def parse_from():
```

### Parser().parse_if

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L217)

```python
def parse_if():
```

Parse an if construct.

### Parser().parse_import

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L304)

```python
def parse_import():
```

### Parser().parse_import_context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L282)

```python
def parse_import_context(node, default):
```

### Parser().parse_include

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L292)

```python
def parse_include():
```

### Parser().parse_list

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L667)

```python
def parse_list():
```

### Parser().parse_macro

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L389)

```python
def parse_macro():
```

### Parser().parse_math1

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L511)

```python
def parse_math1():
```

### Parser().parse_math2

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L532)

```python
def parse_math2():
```

### Parser().parse_not

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L482)

```python
def parse_not():
```

### Parser().parse_or

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L464)

```python
def parse_or():
```

### Parser().parse_postfix

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L694)

```python
def parse_postfix(node):
```

### Parser().parse_pow

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L543)

```python
def parse_pow():
```

### Parser().parse_primary

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L569)

```python
def parse_primary():
```

### Parser().parse_print

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L396)

```python
def parse_print():
```

### Parser().parse_set

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L187)

```python
def parse_set():
```

Parse an assign statement.

### Parser().parse_signature

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L353)

```python
def parse_signature(node):
```

### Parser().parse_statement

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L132)

```python
def parse_statement():
```

Parse a single statement.

### Parser().parse_statements

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L160)

```python
def parse_statements(end_tokens, drop_needle=False):
```

Parse multiple statements into a list until one of the end tokens
is reached.  This is used to parse the body of statements as it also
parses template data if appropriate.  The parser checks first if the
current token is a colon and skips it if there is one.  Then it checks
for the block end and parses until if one of the `end_tokens` is
reached.  Per default the active token in the stream at the end of
the call is the matched end token.  If this is not wanted `drop_needle`
can be set to `True` and the end token is removed.

### Parser().parse_subscribed

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L749)

```python
def parse_subscribed():
```

### Parser().parse_subscript

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L722)

```python
def parse_subscript(node):
```

### Parser().parse_test

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L849)

```python
def parse_test(node):
```

### Parser().parse_tuple

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L602)

```python
def parse_tuple(
    simplified=False,
    with_condexpr=True,
    extra_end_rules=None,
    explicit_parentheses=False,
):
```

Works like [Parser().parse_expression](#parserparse_expression) but if multiple expressions are
delimited by a comma a class `jinja2.nodes.Tuple` node is created.
This method could also return a regular expression instead of a tuple
if no commas where found.

The default parsing mode is a full tuple.  If `simplified` is `True`
only names and literals are parsed.  The `no_condexpr` parameter is
forwarded to :meth:[Parser().parse_expression](#parserparse_expression).

Because tuples do not require delimiters and may end in a bogus comma
an extra hint is needed that marks the end of a tuple.  For example
for loops support tuples between `for` and `in`.  In that case the
`extra_end_rules` is set to ``['name:in']``.

`explicit_parentheses` is true if the parsing was triggered by an
expression in parentheses.  This is used to figure out if an empty
tuple is a valid expression or not.

### Parser().parse_unary

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L553)

```python
def parse_unary(with_filter=True):
```

### Parser().parse_with

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L235)

```python
def parse_with():
```

### Parser().subparse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\parser.py#L887)

```python
def subparse(end_tokens=None):
```
