# Ext

> Auto-generated documentation for [env.Lib.site-packages.jinja2.ext](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py) module.

Extension API for adding custom tags and behavior.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Jinja2](index.md#jinja2) / Ext
    - [AutoEscapeExtension](#autoescapeextension)
    - [DebugExtension](#debugextension)
        - [DebugExtension().parse](#debugextensionparse)
    - [ExprStmtExtension](#exprstmtextension)
        - [ExprStmtExtension().parse](#exprstmtextensionparse)
    - [Extension](#extension)
        - [Extension().attr](#extensionattr)
        - [Extension().bind](#extensionbind)
        - [Extension().call_method](#extensioncall_method)
        - [Extension().filter_stream](#extensionfilter_stream)
        - [Extension().parse](#extensionparse)
        - [Extension().preprocess](#extensionpreprocess)
    - [ExtensionRegistry](#extensionregistry)
    - [InternationalizationExtension](#internationalizationextension)
        - [InternationalizationExtension().parse](#internationalizationextensionparse)
    - [LoopControlExtension](#loopcontrolextension)
        - [LoopControlExtension().parse](#loopcontrolextensionparse)
    - [WithExtension](#withextension)
    - [babel_extract](#babel_extract)
    - [extract_from_ast](#extract_from_ast)

#### Attributes

- `GETTEXT_FUNCTIONS` - the only real useful gettext functions for a Jinja template.  Note
  that ugettext must be assigned to gettext as Jinja doesn't support
  non unicode strings.: `('_', 'gettext', 'ngettext')`
- `i18n` - : nicer import names: `InternationalizationExtension`

## AutoEscapeExtension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L466)

```python
class AutoEscapeExtension(Extension):
```

#### See also

- [Extension](#extension)

## DebugExtension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L470)

```python
class DebugExtension(Extension):
```

A ``{% debug %}`` tag that dumps the available variables,
filters, and tests.

```html+jinja
<pre>{% debug %}</pre>
```

```text
{'context': {'cycler': <class 'jinja2.utils.Cycler'>,
             ...,
             'namespace': <class 'jinja2.utils.Namespace'>},
 'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd',
             ..., 'urlencode', 'urlize', 'wordcount', 'wordwrap', 'xmlattr'],
 'tests': ['!=', '<', '<=', '==', '>', '>=', 'callable', 'defined',
           ..., 'odd', 'sameas', 'sequence', 'string', 'undefined', 'upper']}
```

#### Notes

Added in version 2.11.0

#### See also

- [Extension](#extension)

### DebugExtension().parse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L493)

```python
def parse(parser):
```

## ExprStmtExtension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L437)

```python
class ExprStmtExtension(Extension):
```

Adds a [do](#ext) tag to Jinja that works like the print statement just
that it doesn't print the return value.

#### See also

- [Extension](#extension)

### ExprStmtExtension().parse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L444)

```python
def parse(parser):
```

## Extension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L50)

```python
class Extension(with_metaclass(ExtensionRegistry, object)):
    def __init__(environment):
```

Extensions can be used to add extra functionality to the Jinja template
system at the parser level.  Custom extensions are bound to an environment
but may not store environment specific data on `self`.  The reason for
this is that an extension can be bound to another environment (for
overlays) by creating a copy and reassigning the `environment` attribute.

As extensions are created by the environment they cannot accept any
arguments for configuration.  One may want to work around that by using
a factory function, but that is not possible as extensions are identified
by their import name.  The correct way to configure the extension is
storing the configuration values on the environment.  Because this way the
environment ends up acting as central configuration storage the
attributes may clash which is why extensions have to ensure that the names
they choose for configuration are not too generic.  ``prefix`` for example
is a terrible name, ``fragment_cache_prefix`` on the other hand is a good
name as includes the name of the extension (fragment cache).

#### Attributes

- `tags` - : if this extension parses this is the list of tags it's listening to.: `set()`
- `priority` - : the priority of that extension.  This is especially useful for
  : extensions that preprocess values.  A lower value means higher
  : priority.
  :
  : .. versionadded:: 2.4: `100`

### Extension().attr

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L112)

```python
def attr(name, lineno=None):
```

Return an attribute node for the current extension.  This is useful
to pass constants on extensions to generated template code.

```python
self.attr('_my_attribute', lineno=lineno)
```

### Extension().bind

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L82)

```python
def bind(environment):
```

Create a copy of this extension bound to another environment.

### Extension().call_method

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L122)

```python
def call_method(
    name,
    args=None,
    kwargs=None,
    dyn_args=None,
    dyn_kwargs=None,
    lineno=None,
):
```

Call a method of the extension.  This is a shortcut for
:meth:[Extension().attr](#extensionattr) + class `jinja2.nodes.Call`.

### Extension().filter_stream

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L96)

```python
def filter_stream(stream):
```

It's passed a class `jinja2.lexer.TokenStream` that can be used
to filter tokens returned.  This method has to return an iterable of
class `jinja2.lexer.Token`\s, but it doesn't have to return a
class `jinja2.lexer.TokenStream`.

### Extension().parse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L104)

```python
def parse(parser):
```

If any of the :attr:[tags](#extension) matched this method is called with the
parser as first argument.  The token the parser stream is pointing at
is the name token that matched.  This method has to return one or a
list of multiple nodes.

### Extension().preprocess

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L89)

```python
def preprocess(source, name, filename=None):
```

This method is called before the actual lexing and can be used to
preprocess the source.  The `filename` is optional.  The return value
must be the preprocessed source.

## ExtensionRegistry

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L41)

```python
class ExtensionRegistry(type):
```

Gives the extension an unique identifier.

## InternationalizationExtension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L174)

```python
class InternationalizationExtension(Extension):
    def __init__(environment):
```

This extension adds gettext support to Jinja.

#### See also

- [Extension](#extension)

### InternationalizationExtension().parse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L229)

```python
def parse(parser):
```

Parse a translatable tag.

## LoopControlExtension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L450)

```python
class LoopControlExtension(Extension):
```

Adds break and continue to the template engine.

#### See also

- [Extension](#extension)

### LoopControlExtension().parse

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L455)

```python
def parse(parser):
```

## WithExtension

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L462)

```python
class WithExtension(Extension):
```

#### See also

- [Extension](#extension)

## babel_extract

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L619)

```python
def babel_extract(fileobj, keywords, comment_tags, options):
```

Babel extraction method for Jinja templates.

#### Notes

Changed in version 2.3
   Basic support for translation comments was added.  If `comment_tags`
   is now set to a list of keywords for extraction, the extractor will
   try to find the best preceding comment that begins with one of the
   keywords.  For best results, make sure to not have more than one
   gettext call in one line of code and the matching comment in the
   same line or the line before.

Changed in version 2.5.1
   The `newstyle_gettext` flag can be set to `True` to enable newstyle
   gettext calls.

Changed in version 2.7
   A `silent` option can now be provided.  If set to `False` template
   syntax errors are propagated instead of being ignored.

#### Arguments

- `fileobj` - the file-like object the messages should be extracted from
- `keywords` - a list of keywords (i.e. function names) that should be
                 recognized as translation functions
- `comment_tags` - a list of translator tags to search for and include
                     in the results.
- `options` - a dictionary of additional options (optional)

#### Returns

an iterator over ``(lineno, funcname, message, comments)`` tuples.
         (comments will be empty currently)

## extract_from_ast

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\ext.py#L513)

```python
def extract_from_ast(
    node,
    gettext_functions=GETTEXT_FUNCTIONS,
    babel_style=True,
):
```

Extract localizable strings from the given template node.  Per
default this function returns matches in babel style that means non string
parameters as well as keyword arguments are returned as `None`.  This
allows Babel to figure out what you really meant if you are using
gettext functions that allow keyword arguments for placeholder expansion.
If you don't want that behavior set the `babel_style` parameter to `False`
which causes only strings to be returned and parameters are always stored
in tuples.  As a consequence invalid gettext calls (calls without a single
string parameter or string parameters after non-string parameters) are
skipped.

This example explains the behavior:

```python
>>> from jinja2 import Environment
>>> env = Environment()
>>> node = env.parse('{{ (_("foo"), _(), ngettext("foo", "bar", 42)) }}')
>>> list(extract_from_ast(node))
[(1, '_', 'foo'), (1, '_', ()), (1, 'ngettext', ('foo', 'bar', None))]
>>> list(extract_from_ast(node, babel_style=False))
[(1, '_', ('foo',)), (1, 'ngettext', ('foo', 'bar'))]
```

For every string found this function yields a ``(lineno, function,
message)`` tuple, where:

* ``lineno`` is the number of the line on which the string was found,
* ``function`` is the name of the ``gettext`` function used (if the
  string was extracted from embedded Python code), and
*  ``message`` is the string itself (a ``unicode`` object, or a tuple
   of ``unicode`` objects for functions with multiple string arguments).

This extraction function operates on the AST and is because of that unable
to extract any comments.  For comment support you have to use the babel
extraction interface or extract comments yourself.

#### See also

- [GETTEXT_FUNCTIONS](#gettext_functions)
