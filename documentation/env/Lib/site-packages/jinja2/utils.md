# Utils

> Auto-generated documentation for [env.Lib.site-packages.jinja2.utils](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py) module.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Jinja2](index.md#jinja2) / Utils
    - [Cycler](#cycler)
        - [Cycler().current](#cyclercurrent)
        - [Cycler().next](#cyclernext)
        - [Cycler().reset](#cyclerreset)
    - [Joiner](#joiner)
    - [LRUCache](#lrucache)
        - [LRUCache().\_\_contains\_\_](#lrucache__contains__)
        - [LRUCache().\_\_delitem\_\_](#lrucache__delitem__)
        - [LRUCache().\_\_getitem\_\_](#lrucache__getitem__)
        - [LRUCache().\_\_len\_\_](#lrucache__len__)
        - [LRUCache().\_\_reversed\_\_](#lrucache__reversed__)
        - [LRUCache().\_\_setitem\_\_](#lrucache__setitem__)
        - [LRUCache().clear](#lrucacheclear)
        - [LRUCache().copy](#lrucachecopy)
        - [LRUCache().get](#lrucacheget)
        - [LRUCache().items](#lrucacheitems)
        - [LRUCache().iteritems](#lrucacheiteritems)
        - [LRUCache().iterkeys](#lrucacheiterkeys)
        - [LRUCache().itervalue](#lrucacheitervalue)
        - [LRUCache().itervalues](#lrucacheitervalues)
        - [LRUCache().keys](#lrucachekeys)
        - [LRUCache().setdefault](#lrucachesetdefault)
        - [LRUCache().values](#lrucachevalues)
    - [Namespace](#namespace)
    - [clear_caches](#clear_caches)
    - [consume](#consume)
    - [contextfunction](#contextfunction)
    - [environmentfunction](#environmentfunction)
    - [evalcontextfunction](#evalcontextfunction)
    - [generate_lorem_ipsum](#generate_lorem_ipsum)
    - [htmlsafe_json_dumps](#htmlsafe_json_dumps)
    - [import_string](#import_string)
    - [internalcode](#internalcode)
    - [is_undefined](#is_undefined)
    - [object_type_repr](#object_type_repr)
    - [open_if_exists](#open_if_exists)
    - [pformat](#pformat)
    - [select_autoescape](#select_autoescape)
    - [soft_unicode](#soft_unicode)
    - [unicode_urlencode](#unicode_urlencode)
    - [urlize](#urlize)

#### Attributes

- `missing` - special singleton representing missing values for the runtime: `type('MissingType', (), {'__repr__': lambda x: 'missing'})()`
- `internal_code` - internal code: `set()`

## Cycler

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L623)

```python
class Cycler(object):
    def __init__(*items):
```

Cycle through values by yield them one at a time, then restarting
once the end is reached. Available as ``cycler`` in templates.

Similar to ``loop.cycle``, but can be used outside loops or across
multiple loops. For example, render a list of folders and files in a
list, alternating giving them "odd" and "even" classes.

```html+jinja
{% set row_class = cycler("odd", "even") %}
<ul class="browser">
{% for folder in folders %}
  <li class="folder {{ row_class.next() }}">{{ folder }}
{% endfor %}
{% for file in files %}
  <li class="file {{ row_class.next() }}">{{ file }}
{% endfor %}
</ul>
```

#### Arguments

- `items` - Each positional argument will be yielded in the order
    given for each cycle.

#### Notes

Added in version 2.1

### Cycler().current

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L659)

```python
@property
def current():
```

Return the current item. Equivalent to the item that will be
returned next time :meth:[Cycler().next](#cyclernext) is called.

### Cycler().next

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L666)

```python
def next():
```

Return the current item, then advance :attr:[Cycler().current](#cyclercurrent) to the
next item.

### Cycler().reset

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L655)

```python
def reset():
```

Resets the current item to the first item.

## Joiner

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L677)

```python
class Joiner(object):
    def __init__(sep=', '):
```

A joining helper for templates.

## LRUCache

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L336)

```python
class LRUCache(object):
    def __init__(capacity):
```

A simple LRU Cache implementation.

### LRUCache().\_\_contains\_\_

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L404)

```python
def __contains__(key):
```

Check if a key exists in this cache.

### LRUCache().\_\_delitem\_\_

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L452)

```python
def __delitem__(key):
```

Remove an item from the cache dict.
Raise a `KeyError` if it does not exist.

### LRUCache().\_\_getitem\_\_

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L415)

```python
def __getitem__(key):
```

Get an item from the cache. Moves the item up so that it has the
highest priority then.

Raise a `KeyError` if it does not exist.

### LRUCache().\_\_len\_\_

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L408)

```python
def __len__():
```

Return the current size of the cache.

### LRUCache().\_\_reversed\_\_

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L525)

```python
def __reversed__():
```

Iterate over the keys in the cache dict, oldest items
coming first.

### LRUCache().\_\_setitem\_\_

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L437)

```python
def __setitem__(key, value):
```

Sets the value for an item. Moves the item up so that it
has the highest priority then.

### LRUCache().clear

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L395)

```python
def clear():
```

Clear the cache.

### LRUCache().copy

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L371)

```python
def copy():
```

Return a shallow copy of the instance.

### LRUCache().get

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L378)

```python
def get(key, default=None):
```

Return an item from the cache dict or `default`

### LRUCache().items

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L466)

```python
def items():
```

Return a list of items.

### LRUCache().iteritems

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L472)

```python
def iteritems():
```

Iterate over all items.

### LRUCache().iterkeys

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L510)

```python
def iterkeys():
```

Iterate over all keys in the cache dict, ordered by
the most recent usage.

### LRUCache().itervalue

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L486)

```python
def itervalue():
```

Iterate over all values.

### LRUCache().itervalues

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L496)

```python
def itervalues():
```

Iterate over all values.

### LRUCache().keys

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L506)

```python
def keys():
```

Return a list of all keys ordered by most recent usage.

### LRUCache().setdefault

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L385)

```python
def setdefault(key, default=None):
```

Set `default` if the key is not in the cache otherwise
leave unchanged. Return the value of this key.

### LRUCache().values

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L482)

```python
def values():
```

Return a list of all values.

## Namespace

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L691)

```python
class Namespace(object):
    def __init__(**kwargs):
```

A namespace object that can hold arbitrary attributes.  It may be
initialized from a dictionary or with keyword arguments.

## clear_caches

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L112)

```python
def clear_caches():
```

Jinja keeps internal caches for environments and lexers.  These are
used so that Jinja doesn't have to recreate environments and lexers all
the time.  Normally you don't have to care about that but if you are
measuring memory consumption you may want to clean the caches.

## consume

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L106)

```python
def consume(iterable):
```

Consumes an iterable without doing anything with it.

## contextfunction

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L44)

```python
def contextfunction(f):
```

This decorator can be used to mark a function or method context callable.
A context callable is passed the active class `Context` as first argument when
called from the template.  This is useful if a function wants to get access
to the context or functions provided on the context object.  For example
a function that returns a sorted list of template variables the current
template exports could look like this

```python
@contextfunction
def get_exported_names(context):
    return sorted(context.exported_vars)
```

## environmentfunction

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L73)

```python
def environmentfunction(f):
```

This decorator can be used to mark a function or method as environment
callable.  This decorator works exactly like the :func:[contextfunction](#contextfunction)
decorator just that the first argument is the active class `Environment`
and not context.

## evalcontextfunction

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L60)

```python
def evalcontextfunction(f):
```

This decorator can be used to mark a function or method as an eval
context callable.  This is similar to the :func:[contextfunction](#contextfunction)
but instead of passing the context, an evaluation context object is
passed.  For more information about the eval context, see
:ref:`eval-context`.

#### Notes

Added in version 2.4

## generate_lorem_ipsum

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L258)

```python
def generate_lorem_ipsum(n=5, html=True, min=20, max=100):
```

Generate some lorem ipsum for the template.

## htmlsafe_json_dumps

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L593)

```python
def htmlsafe_json_dumps(obj, dumper=None, **kwargs):
```

Works exactly like :func:`dumps` but is safe for use in ``<script>``
tags.  It accepts the same arguments and returns a JSON string.  Note that
this is available in templates through the ``|tojson`` filter which will
also mark the result as safe.  Due to how this function escapes certain
characters this is safe even if used outside of ``<script>`` tags.

The following characters are escaped in strings:

-   ``<``
-   ``>``
-   ``&``
-   ``'``

This makes it safe to embed such strings in any place in HTML with the
notable exception of double quoted attributes.  In that case single
quote your attributes or HTML escape it in addition.

## import_string

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L125)

```python
def import_string(import_name, silent=False):
```

Imports an object based on a string.  This is useful if you want to
use import paths as endpoints or something similar.  An import path can
be specified either in dotted notation (``xml.sax.saxutils.escape``)
or with a colon as object delimiter (``xml.sax.saxutils:escape``).

If the `silent` is True the return value will be `None` if the import
fails.

#### Returns

imported object

## internalcode

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L83)

```python
def internalcode(f):
```

Marks the function as internally used

## is_undefined

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L89)

```python
def is_undefined(obj):
```

Check if the object passed is undefined.  This does nothing more than
performing an instance check against class `Undefined` but looks nicer.
This can be used for custom filters or tests that want to react to
undefined variables.  For example a custom default filter can look like
this

```python
def default(var, default=''):
    if is_undefined(var):
        return default
    return var
```

## object_type_repr

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L159)

```python
def object_type_repr(obj):
```

Returns the name of the object's type.  For some recognized
singletons the name of the object is returned instead. (For
example for `None` and `Ellipsis`).

## open_if_exists

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L149)

```python
def open_if_exists(filename, mode='rb'):
```

Returns a file descriptor for the filename if that file exists,
otherwise ``None``.

## pformat

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L180)

```python
def pformat(obj, verbose=False):
```

Prettyprint an object.  Either use the `pretty` library or the
builtin `pprint`.

## select_autoescape

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L537)

```python
def select_autoescape(
    enabled_extensions=('html', 'htm', 'xml'),
    disabled_extensions=(),
    default_for_string=True,
    default=False,
):
```

Intelligently sets the initial value of autoescaping based on the
filename of the template.  This is the recommended way to configure
autoescaping if you do not want to write a custom function yourself.

If you want to enable it for all templates created from strings or
for all templates with `.html` and `.xml` extensions

```python
from jinja2 import Environment, select_autoescape
env = Environment(autoescape=select_autoescape(
    enabled_extensions=('html', 'xml'),
    default_for_string=True,
))
```

Example configuration to turn it on at all times except if the template
ends with `.txt`

```python
from jinja2 import Environment, select_autoescape
env = Environment(autoescape=select_autoescape(
    disabled_extensions=('txt',),
    default_for_string=True,
    default=True,
))
```

The `enabled_extensions` is an iterable of all the extensions that
autoescaping should be enabled for.  Likewise `disabled_extensions` is
a list of all templates it should be disabled for.  If a template is
loaded from a string then the default from `default_for_string` is used.
If nothing matches then the initial value of autoescaping is set to the
value of `default`.

For security reasons this function operates case insensitive.

#### Notes

Added in version 2.9

## soft_unicode

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L723)

```python
def soft_unicode(s):
```

## unicode_urlencode

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L307)

```python
def unicode_urlencode(obj, charset='utf-8', for_qs=False):
```

Quote a string for use in a URL using the given charset.

This function is misnamed, it is a wrapper around
:func:`urllib.parse.quote`.

#### Arguments

- `obj` - String or bytes to quote. Other types are converted to
    string then encoded to bytes using the given charset.
- `charset` - Encode text to bytes using this charset.
- `for_qs` - Quote "/" and use "+" for spaces.

## urlize

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\jinja2\utils.py#L194)

```python
def urlize(text, trim_url_limit=None, rel=None, target=None):
```

Converts any URLs in text into clickable links. Works on http://,
https:// and www. links. Links can have trailing punctuation (periods,
commas, close-parens) and leading punctuation (opening parens) and
it'll still do the right thing.

If trim_url_limit is not None, the URLs in link text will be limited
to trim_url_limit characters.

If nofollow is True, the URLs in link text will get a rel="nofollow"
attribute.

If target is not None, a target attribute will be added to the link.
