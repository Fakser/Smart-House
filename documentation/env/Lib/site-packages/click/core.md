# Core

> Auto-generated documentation for [env.Lib.site-packages.click.core](..\..\..\..\..\env\Lib\site-packages\click\core.py) module.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Click](index.md#click) / Core
    - [Argument](#argument)
        - [Argument().add_to_parser](#argumentadd_to_parser)
        - [Argument().get_error_hint](#argumentget_error_hint)
        - [Argument().get_usage_pieces](#argumentget_usage_pieces)
        - [Argument().human_readable_name](#argumenthuman_readable_name)
        - [Argument().make_metavar](#argumentmake_metavar)
    - [BaseCommand](#basecommand)
        - [BaseCommand().\_\_call\_\_](#basecommand__call__)
        - [BaseCommand().get_help](#basecommandget_help)
        - [BaseCommand().get_usage](#basecommandget_usage)
        - [BaseCommand().invoke](#basecommandinvoke)
        - [BaseCommand().main](#basecommandmain)
        - [BaseCommand().make_context](#basecommandmake_context)
        - [BaseCommand().parse_args](#basecommandparse_args)
    - [Command](#command)
        - [Command().collect_usage_pieces](#commandcollect_usage_pieces)
        - [Command().format_epilog](#commandformat_epilog)
        - [Command().format_help](#commandformat_help)
        - [Command().format_help_text](#commandformat_help_text)
        - [Command().format_options](#commandformat_options)
        - [Command().format_usage](#commandformat_usage)
        - [Command().get_help](#commandget_help)
        - [Command().get_help_option](#commandget_help_option)
        - [Command().get_help_option_names](#commandget_help_option_names)
        - [Command().get_params](#commandget_params)
        - [Command().get_short_help_str](#commandget_short_help_str)
        - [Command().get_usage](#commandget_usage)
        - [Command().invoke](#commandinvoke)
        - [Command().make_parser](#commandmake_parser)
        - [Command().parse_args](#commandparse_args)
    - [CommandCollection](#commandcollection)
        - [CommandCollection().add_source](#commandcollectionadd_source)
        - [CommandCollection().get_command](#commandcollectionget_command)
        - [CommandCollection().list_commands](#commandcollectionlist_commands)
    - [Context](#context)
        - [Context().abort](#contextabort)
        - [Context().call_on_close](#contextcall_on_close)
        - [Context().close](#contextclose)
        - [Context().command_path](#contextcommand_path)
        - [Context().ensure_object](#contextensure_object)
        - [Context().exit](#contextexit)
        - [Context().fail](#contextfail)
        - [Context().find_object](#contextfind_object)
        - [Context().find_root](#contextfind_root)
        - [Context().forward](#contextforward)
        - [Context().get_help](#contextget_help)
        - [Context().get_usage](#contextget_usage)
        - [Context().invoke](#contextinvoke)
        - [Context().lookup_default](#contextlookup_default)
        - [Context().make_formatter](#contextmake_formatter)
        - [Context().meta](#contextmeta)
        - [Context().scope](#contextscope)
    - [Group](#group)
        - [Group().add_command](#groupadd_command)
        - [Group().command](#groupcommand)
        - [Group().get_command](#groupget_command)
        - [Group().group](#groupgroup)
        - [Group().list_commands](#grouplist_commands)
    - [MultiCommand](#multicommand)
        - [MultiCommand().collect_usage_pieces](#multicommandcollect_usage_pieces)
        - [MultiCommand().format_commands](#multicommandformat_commands)
        - [MultiCommand().format_options](#multicommandformat_options)
        - [MultiCommand().get_command](#multicommandget_command)
        - [MultiCommand().invoke](#multicommandinvoke)
        - [MultiCommand().list_commands](#multicommandlist_commands)
        - [MultiCommand().parse_args](#multicommandparse_args)
        - [MultiCommand().resolve_command](#multicommandresolve_command)
        - [MultiCommand().resultcallback](#multicommandresultcallback)
    - [Option](#option)
        - [Option().add_to_parser](#optionadd_to_parser)
        - [Option().full_process_value](#optionfull_process_value)
        - [Option().get_default](#optionget_default)
        - [Option().get_help_record](#optionget_help_record)
        - [Option().prompt_for_value](#optionprompt_for_value)
        - [Option().resolve_envvar_value](#optionresolve_envvar_value)
        - [Option().value_from_envvar](#optionvalue_from_envvar)
    - [Parameter](#parameter)
        - [Parameter().add_to_parser](#parameteradd_to_parser)
        - [Parameter().consume_value](#parameterconsume_value)
        - [Parameter().full_process_value](#parameterfull_process_value)
        - [Parameter().get_default](#parameterget_default)
        - [Parameter().get_error_hint](#parameterget_error_hint)
        - [Parameter().get_help_record](#parameterget_help_record)
        - [Parameter().get_usage_pieces](#parameterget_usage_pieces)
        - [Parameter().handle_parse_result](#parameterhandle_parse_result)
        - [Parameter().human_readable_name](#parameterhuman_readable_name)
        - [Parameter().make_metavar](#parametermake_metavar)
        - [Parameter().process_value](#parameterprocess_value)
        - [Parameter().resolve_envvar_value](#parameterresolve_envvar_value)
        - [Parameter().type_cast_value](#parametertype_cast_value)
        - [Parameter().value_from_envvar](#parametervalue_from_envvar)
        - [Parameter().value_is_missing](#parametervalue_is_missing)
    - [augment_usage_errors](#augment_usage_errors)
    - [batch](#batch)
    - [fast_exit](#fast_exit)
    - [invoke_param_callback](#invoke_param_callback)
    - [iter_params_for_processing](#iter_params_for_processing)

## Argument

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1968)

```python
class Argument(Parameter):
    def __init__(param_decls, required=None, **attrs):
```

Arguments are positional parameters to a command.  They generally
provide fewer features than options but can have infinite ``nargs``
and are required by default.

All parameters are passed onwards to the parameter constructor.

#### See also

- [Parameter](#parameter)

### Argument().add_to_parser

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L2029)

```python
def add_to_parser(parser, ctx):
```

### Argument().get_error_hint

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L2026)

```python
def get_error_hint(ctx):
```

### Argument().get_usage_pieces

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L2023)

```python
def get_usage_pieces(ctx):
```

### Argument().human_readable_name

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1990)

```python
@property
def human_readable_name():
```

### Argument().make_metavar

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1996)

```python
def make_metavar():
```

## BaseCommand

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L631)

```python
class BaseCommand(object):
    def __init__(name, context_settings=None):
```

The base command implements the minimal API contract of commands.
Most code will never use this as it does not implement a lot of useful
functionality but it can act as the direct subclass of alternative
parsing methods that do not depend on the Click parser.

For instance, this can be used to bridge Click and other systems like
argparse or docopt.

Because base commands do not implement a lot of the API that other
parts of Click take for granted, they are not supported for all
operations.  For instance, they cannot be used with the decorators
usually and they have no built-in callback system.

#### Notes

Changed in version 2.0
   Added the `context_settings` parameter.

#### Arguments

- `name` - the name of the command to use unless a group overrides it.
- `context_settings` - an optional dictionary with defaults that are
                         passed to the context object.

#### Attributes

- `allow_extra_args` - : the default for the :attr:`Context.allow_extra_args` flag.: `False`
- `allow_interspersed_args` - : the default for the :attr:`Context.allow_interspersed_args` flag.: `True`
- `ignore_unknown_options` - : the default for the :attr:`Context.ignore_unknown_options` flag.: `False`

### BaseCommand().\_\_call\_\_

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L827)

```python
def __call__(*args, **kwargs):
```

Alias for :meth:[BaseCommand().main](#basecommandmain).

### BaseCommand().get_help

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L677)

```python
def get_help(ctx):
```

### BaseCommand().get_usage

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L674)

```python
def get_usage(ctx):
```

### BaseCommand().invoke

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L710)

```python
def invoke(ctx):
```

Given a context, this invokes the command.  The default
implementation is raising a not implemented error.

### BaseCommand().main

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L716)

```python
def main(
    args=None,
    prog_name=None,
    complete_var=None,
    standalone_mode=True,
    **extra,
):
```

This is the way to invoke a script with all the bells and
whistles as a command line application.  This will always terminate
the application after a call.  If this is not wanted, ``SystemExit``
needs to be caught.

This method is also available by directly calling the instance of
a :class:[Command](#command).

#### Notes

Added in version 3.0
   Added the `standalone_mode` flag to control the standalone mode.

#### Arguments

- `args` - the arguments that should be used for parsing.  If not
             provided, ``sys.argv[1:]`` is used.
- `prog_name` - the program name that should be used.  By default
                  the program name is constructed by taking the file
                  name from ``sys.argv[0]``.
- `complete_var` - the environment variable that controls the
                     bash completion support.  The default is
                     ``"_<prog_name>_COMPLETE"`` with prog_name in
                     uppercase.
- `standalone_mode` - the default behavior is to invoke the script
                        in standalone mode.  Click will then
                        handle exceptions and convert them into
                        error messages and the function will never
                        return but shut down the interpreter.  If
                        this is set to `False` they will be
                        propagated to the caller and the return
                        value of this function is the return value
                        of :meth:[BaseCommand().invoke](#basecommandinvoke).
- `extra` - extra keyword arguments are forwarded to the context
              constructor.  See :class:[Context](#context) for more information.

### BaseCommand().make_context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L680)

```python
def make_context(info_name, args, parent=None, **extra):
```

This function when given an info name and arguments will kick
off the parsing and create a new :class:[Context](#context).  It does not
invoke the actual command callback though.

#### Arguments

- `info_name` - the info name for this invokation.  Generally this
                  is the most descriptive name for the script or
                  command.  For the toplevel script it's usually
                  the name of the script, for commands below it it's
                  the name of the script.
- `args` - the arguments to parse as list of strings.
- `parent` - the parent context if available.
- `extra` - extra keyword arguments forwarded to the context
              constructor.

### BaseCommand().parse_args

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L703)

```python
def parse_args(ctx, args):
```

Given a context and a list of arguments this creates the parser
and parses the arguments, then modifies the context as necessary.
This is automatically invoked by :meth:[BaseCommand().make_context](#basecommandmake_context).

## Command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L832)

```python
class Command(BaseCommand):
    def __init__(
        name,
        context_settings=None,
        callback=None,
        params=None,
        help=None,
        epilog=None,
        short_help=None,
        options_metavar='[OPTIONS]',
        add_help_option=True,
        no_args_is_help=False,
        hidden=False,
        deprecated=False,
    ):
```

Commands are the basic building block of command line interfaces in
Click.  A basic command handles command line parsing and might dispatch
more parsing to commands nested below it.

#### Notes

Changed in version 2.0
   Added the `context_settings` parameter.

Changed in version 7.1
   Added the `no_args_is_help` parameter.

#### Arguments

- `name` - the name of the command to use unless a group overrides it.
- `context_settings` - an optional dictionary with defaults that are
                         passed to the context object.
- `callback` - the callback to invoke.  This is optional.
- `params` - the parameters to register with this command.  This can
               be either :class:[Option](#option) or :class:[Argument](#argument) objects.
- `help` - the help string to use for this command.
- `epilog` - like the help string but it's printed at the end of the
               help page after everything else.
- `short_help` - the short help to use for this command.  This is
                   shown on the command listing of the parent command.
- `add_help_option` - by default each command registers a ``--help``
                        option.  This can be disabled by this parameter.
- `no_args_is_help` - this controls what happens if no arguments are
                        provided.  This option is disabled by default.
                        If enabled this will add ``--help`` as argument
                        if no arguments are passed
- `hidden` - hide this command from help outputs.

- `deprecated` - issues a message indicating that
                         the command is deprecated.

#### See also

- [BaseCommand](#basecommand)

### Command().collect_usage_pieces

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L925)

```python
def collect_usage_pieces(ctx):
```

Returns all the pieces that go into the usage line and returns
it as a list of strings.

### Command().format_epilog

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1032)

```python
def format_epilog(ctx, formatter):
```

Writes the epilog into the formatter if it exists.

### Command().format_help

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L989)

```python
def format_help(ctx, formatter):
```

Writes the help into the formatter if it exists.

This is a low-level method called by :meth:[Command().get_help](#commandget_help).

This calls the following methods:

-   :meth:[Command().format_usage](#commandformat_usage)
-   :meth:[Command().format_help_text](#commandformat_help_text)
-   :meth:[Command().format_options](#commandformat_options)
-   :meth:[Command().format_epilog](#commandformat_epilog)

### Command().format_help_text

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1006)

```python
def format_help_text(ctx, formatter):
```

Writes the help text to the formatter if it exists.

### Command().format_options

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1020)

```python
def format_options(ctx, formatter):
```

Writes all the options into the formatter if they exist.

### Command().format_usage

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L917)

```python
def format_usage(ctx, formatter):
```

Writes the usage line into the formatter.

This is a low-level method called by :meth:[Command().get_usage](#commandget_usage).

### Command().get_help

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L969)

```python
def get_help(ctx):
```

Formats the help into a string and returns it.

Calls :meth:[Command().format_help](#commandformat_help) internally.

### Command().get_help_option

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L942)

```python
def get_help_option(ctx):
```

Returns the help option object.

### Command().get_help_option_names

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L934)

```python
def get_help_option_names(ctx):
```

Returns the names for the help option.

### Command().get_params

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L910)

```python
def get_params(ctx):
```

### Command().get_short_help_str

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L978)

```python
def get_short_help_str(limit=45):
```

Gets short help for the command or makes it by shortening the
long help string.

### Command().get_usage

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L901)

```python
def get_usage(ctx):
```

Formats the usage line into a string and returns it.

Calls :meth:[Command().format_usage](#commandformat_usage) internally.

### Command().invoke

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1060)

```python
def invoke(ctx):
```

Given a context, this invokes the attached callback (if it exists)
in the right way.

### Command().make_parser

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L962)

```python
def make_parser(ctx):
```

Creates the underlying option parser for this command.

### Command().parse_args

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1039)

```python
def parse_args(ctx, args):
```

## CommandCollection

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1390)

```python
class CommandCollection(MultiCommand):
    def __init__(name=None, sources=None, **attrs):
```

A command collection is a multi command that merges multiple multi
commands together into one.  This is a straightforward implementation
that accepts a list of different multi commands as sources and
provides all the commands for each of them.

#### See also

- [MultiCommand](#multicommand)

### CommandCollection().add_source

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1402)

```python
def add_source(multi_cmd):
```

Adds a new multi command to the chain dispatcher.

### CommandCollection().get_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1406)

```python
def get_command(ctx, cmd_name):
```

### CommandCollection().list_commands

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1414)

```python
def list_commands(ctx):
```

## Context

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L159)

```python
class Context(object):
    def __init__(
        command,
        parent=None,
        info_name=None,
        obj=None,
        auto_envvar_prefix=None,
        default_map=None,
        terminal_width=None,
        max_content_width=None,
        resilient_parsing=False,
        allow_extra_args=None,
        allow_interspersed_args=None,
        ignore_unknown_options=None,
        help_option_names=None,
        token_normalize_func=None,
        color=None,
        show_default=None,
    ):
```

The context is a special internal object that holds state relevant
for the script execution at every single level.  It's normally invisible
to commands unless they opt-in to getting access to it.

The context is useful as it can pass internal objects around and can
control special execution features such as reading data from
environment variables.

A context can be used as context manager in which case it will call
:meth:`close` on teardown.

#### Notes

Added in version 2.0
   Added the `resilient_parsing`, `help_option_names`,
   `token_normalize_func` parameters.

Added in version 3.0
   Added the `allow_extra_args` and `allow_interspersed_args`
   parameters.

Added in version 4.0
   Added the `color`, `ignore_unknown_options`, and
   `max_content_width` parameters.

Added in version 7.1
   Added the `show_default` parameter.

#### Arguments

- `command` - the command class for this context.
- `parent` - the parent context.
- `info_name` - the info name for this invocation.  Generally this
                  is the most descriptive name for the script or
                  command.  For the toplevel script it is usually
                  the name of the script, for commands below it it's
                  the name of the script.
- `obj` - an arbitrary object of user data.
- `auto_envvar_prefix` - the prefix to use for automatic environment
                           variables.  If this is `None` then reading
                           from environment variables is disabled.  This
                           does not affect manually set environment
                           variables which are always read.
- `default_map` - a dictionary (like object) with default values
                    for parameters.
- `terminal_width` - the width of the terminal.  The default is
                       inherit from parent context.  If no context
                       defines the terminal width then auto
                       detection will be applied.
- `max_content_width` - the maximum width for content rendered by
                          Click (this currently only affects help
                          pages).  This defaults to 80 characters if
                          not overridden.  In other words: even if the
                          terminal is larger than that, Click will not
                          format things wider than 80 characters by
                          default.  In addition to that, formatters might
                          add some safety mapping on the right.
- `resilient_parsing` - if this flag is enabled then Click will
                          parse without any interactivity or callback
                          invocation.  Default values will also be
                          ignored.  This is useful for implementing
                          things such as completion support.
- `allow_extra_args` - if this is set to `True` then extra arguments
                         at the end will not raise an error and will be
                         kept on the context.  The default is to inherit
                         from the command.
- `allow_interspersed_args` - if this is set to `False` then options
                                and arguments cannot be mixed.  The
                                default is to inherit from the command.
- `ignore_unknown_options` - instructs click to ignore options it does
                               not know and keeps them for later
                               processing.
- `help_option_names` - optionally a list of strings that define how
                          the default help parameter is named.  The
                          default is ``['--help']``.
- `token_normalize_func` - an optional function that is used to
                             normalize tokens (options, choices,
                             etc.).  This for instance can be used to
                             implement case insensitive behavior.
- `color` - controls if the terminal supports ANSI colors or not.  The
              default is autodetection.  This is only needed if ANSI
              codes are used in texts that Click prints which is by
              default not the case.  This for instance would affect
              help output.
- `show_default` - if True, shows defaults for all options.
                Even if an option is later created with show_default=False,
                this command-level setting overrides it.

### Context().abort

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L552)

```python
def abort():
```

Aborts the script.

### Context().call_on_close

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L479)

```python
def call_on_close(f):
```

This decorator remembers a function as callback that should be
executed when the context tears down.  This is most useful to bind
resource handling to the script execution.  For instance, file objects
opened by the class `File` type will register their close callbacks
here.

#### Arguments

- `f` - the function to execute on teardown.

### Context().close

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L491)

```python
def close():
```

Invokes all close callbacks.

### Context().command_path

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L497)

```python
@property
def command_path():
```

The computed command path.  This is used for the ``usage``
information on the help page.  It's automatically created by
combining the info names of the chain of contexts to the root.

### Context().ensure_object

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L525)

```python
def ensure_object(object_type):
```

Like :meth:[Context().find_object](#contextfind_object) but sets the innermost object to a
new instance of `object_type` if it does not exist.

### Context().exit

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L556)

```python
def exit(code=0):
```

Exits the application with a given exit code.

### Context().fail

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L544)

```python
def fail(message):
```

Aborts the execution of the program with a specific error
message.

#### Arguments

- `message` - the error message to fail with.

### Context().find_object

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L517)

```python
def find_object(object_type):
```

Finds the closest object of a given type.

### Context().find_root

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L510)

```python
def find_root():
```

Finds the outermost context.

### Context().forward

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L612)

```python
def forward(**kwargs):
```

Similar to :meth:[Context().invoke](#contextinvoke) but fills in default keyword
arguments from the current context if the other command expects
it.  This cannot invoke callbacks directly, only other commands.

### Context().get_help

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L566)

```python
def get_help():
```

Helper method to get formatted help page for the current
context and command.

### Context().get_usage

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L560)

```python
def get_usage():
```

Helper method to get formatted usage string for the current
context and command.

### Context().invoke

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L572)

```python
def invoke(**kwargs):
```

Invokes a command callback in exactly the way it expects.  There
are two ways to invoke this method:

1.  the first argument can be a callback and all other arguments and
    keyword arguments are forwarded directly to the function.
2.  the first argument is a click command object.  In that case all
    arguments are forwarded as well but proper click parameters
    (options and click arguments) must be keyword arguments and Click
    will fill in defaults.

Note that before Click 3.2 keyword arguments were not properly filled
in against the intention of this code and no context was created.  For
more information about this change and why it was done in a bugfix
release see :ref:`upgrade-to-3.2`.

### Context().lookup_default

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L534)

```python
def lookup_default(name):
```

Looks up the default for a parameter name.  This by default
looks into the attribute `default_map` if available.

### Context().make_formatter

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L473)

```python
def make_formatter():
```

Creates the formatter for the help and usage output.

### Context().meta

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L445)

```python
@property
def meta():
```

This is a dictionary which is shared with all the contexts
that are nested.  It exists so that click utilities can store some
state here if they need to.  It is however the responsibility of
that code to manage this dictionary well.

The keys are supposed to be unique dotted strings.  For instance
module paths are a good choice for it.  What is stored in there is
irrelevant for the operation of click.  However what is important is
that code that places data here adheres to the general semantics of
the system.

Example usage

```python
LANG_KEY = f'{__name__}.lang'

def set_language(value):
    ctx = get_current_context()
    ctx.meta[LANG_KEY] = value

def get_language():
    return get_current_context().meta.get(LANG_KEY, 'en_US')
```

#### Notes

Added in version 5.0

### Context().scope

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L407)

```python
@contextmanager
def scope(cleanup=True):
```

This helper method can be used with the context object to promote
it to the current thread local (see :func:`get_current_context`).
The default behavior of this is to invoke the cleanup functions which
can be disabled by setting `cleanup` to `False`.  The cleanup
functions are typically used for things such as closing file handles.

If the cleanup is intended the context object can also be directly
used as a context manager.

Example usage

```python
with ctx.scope():
    assert get_current_context() is ctx
```

This is equivalent

```python
with ctx:
    assert get_current_context() is ctx
```

#### Notes

Added in version 5.0

#### Arguments

- `cleanup` - controls if the cleanup functions should be run or
                not.  The default is to run these functions.  In
                some situations the context only wants to be
                temporarily pushed in which case this can be disabled.
                Nested pushes automatically defer the cleanup.

## Group

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1331)

```python
class Group(MultiCommand):
    def __init__(name=None, commands=None, **attrs):
```

A group allows a command to have subcommands attached.  This is the
most common way to implement nesting in Click.

#### Arguments

- `commands` - a dictionary of commands.

#### See also

- [MultiCommand](#multicommand)

### Group().add_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1343)

```python
def add_command(cmd, name=None):
```

Registers another :class:[Command](#command) with this group.  If the name
is not provided, the name of the command is used.

### Group().command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1353)

```python
def command(*args, **kwargs):
```

A shortcut decorator for declaring and attaching a command to
the group.  This takes the same arguments as :func:`command` but
immediately registers the created command with this instance by
calling into :meth:[Group().add_command](#groupadd_command).

### Group().get_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1383)

```python
def get_command(ctx, cmd_name):
```

### Group().group

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1368)

```python
def group(*args, **kwargs):
```

A shortcut decorator for declaring and attaching a group to
the group.  This takes the same arguments as :func:`group` but
immediately registers the created command with this instance by
calling into :meth:[Group().add_command](#groupadd_command).

### Group().list_commands

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1386)

```python
def list_commands(ctx):
```

## MultiCommand

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1069)

```python
class MultiCommand(Command):
    def __init__(
        name=None,
        invoke_without_command=False,
        no_args_is_help=None,
        subcommand_metavar=None,
        chain=False,
        result_callback=None,
        **attrs,
    ):
```

A multi command is the basic implementation of a command that
dispatches to subcommands.  The most common version is the
:class:[Group](#group).

#### Arguments

- `invoke_without_command` - this controls how the multi command itself
                               is invoked.  By default it's only invoked
                               if a subcommand is provided.
- `no_args_is_help` - this controls what happens if no arguments are
                        provided.  This option is enabled by default if
                        `invoke_without_command` is disabled or disabled
                        if it's enabled.  If enabled this will add
                        ``--help`` as argument if no arguments are
                        passed.
- `subcommand_metavar` - the string that is used in the documentation
                           to indicate the subcommand place.
- `chain` - if this is set to `True` chaining of multiple subcommands
              is enabled.  This restricts the form of commands in that
              they cannot have optional arguments but it allows
              multiple commands to be chained together.
- `result_callback` - the result callback to attach to this multi
                        command.

#### See also

- [Command](#command)

### MultiCommand().collect_usage_pieces

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1130)

```python
def collect_usage_pieces(ctx):
```

### MultiCommand().format_commands

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1179)

```python
def format_commands(ctx, formatter):
```

Extra format methods for multi methods that adds all the commands
after the options.

### MultiCommand().format_options

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1135)

```python
def format_options(ctx, formatter):
```

### MultiCommand().get_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1318)

```python
def get_command(ctx, cmd_name):
```

Given a context and a command name, this returns a
:class:[Command](#command) object if it exists or returns `None`.

### MultiCommand().invoke

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1221)

```python
def invoke(ctx):
```

### MultiCommand().list_commands

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1324)

```python
def list_commands(ctx):
```

Returns a list of subcommand names in the order they should
appear.

### MultiCommand().parse_args

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1207)

```python
def parse_args(ctx, args):
```

### MultiCommand().resolve_command

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1292)

```python
def resolve_command(ctx, args):
```

### MultiCommand().resultcallback

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1139)

```python
def resultcallback(replace=False):
```

Adds a result callback to the chain command.  By default if a
result callback is already registered this will chain them but
this can be disabled with the `replace` parameter.  The result
callback is invoked with the return value of the subcommand
(or the list of return values from all subcommands if chaining
is enabled) as well as the parameters as they would be passed
to the main callback.

Example

```python
@click.group()
@click.option('-i', '--input', default=23)
def cli(input):
    return 42

@cli.resultcallback()
def process_result(result, input):
    return result + input
```

#### Notes

Added in version 3.0

#### Arguments

- `replace` - if set to `True` an already existing result
                callback will be removed.

## Option

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1653)

```python
class Option(Parameter):
    def __init__(
        param_decls=None,
        show_default=False,
        prompt=False,
        confirmation_prompt=False,
        hide_input=False,
        is_flag=None,
        flag_value=None,
        multiple=False,
        count=False,
        allow_from_autoenv=True,
        type=None,
        help=None,
        hidden=False,
        show_choices=True,
        show_envvar=False,
        **attrs,
    ):
```

Options are usually optional values on the command line and
have some extra features that arguments don't have.

All other parameters are passed onwards to the parameter constructor.

#### Arguments

- `show_default` - controls if the default value should be shown on the
                     help page. Normally, defaults are not shown. If this
                     value is a string, it shows the string instead of the
                     value. This is particularly useful for dynamic options.
- `show_envvar` - controls if an environment variable should be shown on
                    the help page.  Normally, environment variables
                    are not shown.
- `prompt` - if set to `True` or a non empty string then the user will be
               prompted for input.  If set to `True` the prompt will be the
               option name capitalized.
- `confirmation_prompt` - if set then the value will need to be confirmed
                            if it was prompted for.
- `hide_input` - if this is `True` then the input on the prompt will be
                   hidden from the user.  This is useful for password
                   input.
- `is_flag` - forces this option to act as a flag.  The default is
                auto detection.
- `flag_value` - which value should be used for this flag if it's
                   enabled.  This is set to a boolean automatically if
                   the option string contains a slash to mark two options.
- `multiple` - if this is set to `True` then the argument is accepted
                 multiple times and recorded.  This is similar to ``nargs``
                 in how it works but supports arbitrary number of
                 arguments.
- `count` - this flag makes an option increment an integer.
- `allow_from_autoenv` - if this is enabled then the value of this
                           parameter will be pulled from an environment
                           variable in case a prefix is defined on the
                           context.
- `help` - the help string.
- `hidden` - hide this option from help outputs.

#### See also

- [Parameter](#parameter)

### Option().add_to_parser

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1825)

```python
def add_to_parser(parser, ctx):
```

### Option().full_process_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1962)

```python
def full_process_value(ctx, value):
```

### Option().get_default

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1907)

```python
def get_default(ctx):
```

### Option().get_help_record

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1855)

```python
def get_help_record(ctx):
```

### Option().prompt_for_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1919)

```python
def prompt_for_value(ctx):
```

This is an alternative flow that can be activated in the full
value processing if a value does not exist.  It will prompt the
user until a valid value exists and then returns the processed
value as result.

### Option().resolve_envvar_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1943)

```python
def resolve_envvar_value(ctx):
```

### Option().value_from_envvar

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1951)

```python
def value_from_envvar(ctx):
```

## Parameter

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1421)

```python
class Parameter(object):
    def __init__(
        param_decls=None,
        type=None,
        required=False,
        default=None,
        callback=None,
        nargs=None,
        metavar=None,
        expose_value=True,
        is_eager=False,
        envvar=None,
        autocompletion=None,
    ):
```

A parameter to a command comes in two versions: they are either
:class:[Option](#option)\s or :class:[Argument](#argument)\s.  Other subclasses are currently
not supported by design as some of the internals for parsing are
intentionally not finalized.

Some settings are supported by both options and arguments.

#### Arguments

- `param_decls` - the parameter declarations for this option or
                    argument.  This is a list of flags or argument
                    names.
- `type` - the type that should be used.  Either a class `ParamType`
             or a Python type.  The later is converted into the former
             automatically if supported.
- `required` - controls if this is optional or not.
- `default` - the default value if omitted.  This can also be a callable,
                in which case it's invoked when the default is needed
                without any arguments.
- `callback` - a callback that should be executed after the parameter
                 was matched.  This is called as ``fn(ctx, param,
                 value)`` and needs to return the value.
- `nargs` - the number of arguments to match.  If not ``1`` the return
              value is a tuple instead of single value.  The default for
              nargs is ``1`` (except if the type is a tuple, then it's
              the arity of the tuple).
- `metavar` - how the value is represented in the help page.
- `expose_value` - if this is `True` then the value is passed onwards
                     to the command callback and stored on the context,
                     otherwise it's skipped.
- `is_eager` - eager values are processed before non eager ones.  This
                 should not be set for arguments or it will inverse the
                 order of processing.
- `envvar` - a string or list of strings that are environment variables
               that should be checked.

#### Notes

Changed in version 7.1
    Empty environment variables are ignored rather than taking the
    empty string value. This makes it possible for scripts to clear
    variables if they can't unset them.

Changed in version 2.0
    Changed signature for parameter callback to also be passed the
    parameter. The old callback format will still work, but it will
    raise a warning to give you a chance to migrate the code easier.

### Parameter().add_to_parser

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1536)

```python
def add_to_parser(parser, ctx):
```

### Parameter().consume_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1539)

```python
def consume_value(ctx, opts):
```

### Parameter().full_process_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1588)

```python
def full_process_value(ctx, value):
```

### Parameter().get_default

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1527)

```python
def get_default(ctx):
```

Given a context variable this calculates the default value.

### Parameter().get_error_hint

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1645)

```python
def get_error_hint(ctx):
```

Get a stringified version of the param for use in error messages to
indicate which param caused the error.

### Parameter().get_help_record

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1639)

```python
def get_help_record(ctx):
```

### Parameter().get_usage_pieces

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1642)

```python
def get_usage_pieces(ctx):
```

### Parameter().handle_parse_result

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1619)

```python
def handle_parse_result(ctx, opts, args):
```

### Parameter().human_readable_name

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1510)

```python
@property
def human_readable_name():
```

Returns the human readable name of this parameter.  This is the
same as the name for options, but the metavar for arguments.

### Parameter().make_metavar

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1517)

```python
def make_metavar():
```

### Parameter().process_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1570)

```python
def process_value(ctx, value):
```

Given a value and context this runs the logic to convert the
value as necessary.

### Parameter().resolve_envvar_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1599)

```python
def resolve_envvar_value(ctx):
```

### Parameter().type_cast_value

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1547)

```python
def type_cast_value(ctx, value):
```

Given a value this runs it properly through the type system.
This automatically handles things like `nargs` and `multiple` as
well as composite types.

### Parameter().value_from_envvar

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1613)

```python
def value_from_envvar(ctx):
```

### Parameter().value_is_missing

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L1581)

```python
def value_is_missing(value):
```

## augment_usage_errors

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L126)

```python
@contextmanager
def augment_usage_errors(ctx, param=None):
```

Context manager that attaches extra information to exceptions.

## batch

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L104)

```python
def batch(iterable, batch_size):
```

## fast_exit

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L53)

```python
def fast_exit(code):
```

Exit without garbage collection, this speeds up exit by about 10ms for
things like bash completion.

## invoke_param_callback

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L108)

```python
def invoke_param_callback(callback, ctx, param, value):
```

## iter_params_for_processing

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\core.py#L143)

```python
def iter_params_for_processing(invocation_order, declaration_order):
```

Given a sequence of parameters in the order as should be considered
for processing and an iterable of parameters that exist, this returns
a list in the correct order as they should be processed.
