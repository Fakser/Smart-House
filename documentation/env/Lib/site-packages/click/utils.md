# Utils

> Auto-generated documentation for [env.Lib.site-packages.click.utils](..\..\..\..\..\env\Lib\site-packages\click\utils.py) module.

- [Smart-house-rest-api](..\..\..\..\README.md#description) / [Modules](..\..\..\..\MODULES.md#smart-house-rest-api-modules) / `Env` / `Lib` / `Site-packages` / [Click](index.md#click) / Utils
    - [KeepOpenFile](#keepopenfile)
    - [LazyFile](#lazyfile)
        - [LazyFile().close](#lazyfileclose)
        - [LazyFile().close_intelligently](#lazyfileclose_intelligently)
        - [LazyFile().open](#lazyfileopen)
    - [PacifyFlushWrapper](#pacifyflushwrapper)
        - [PacifyFlushWrapper().flush](#pacifyflushwrapperflush)
    - [echo](#echo)
    - [format_filename](#format_filename)
    - [get_app_dir](#get_app_dir)
    - [get_binary_stream](#get_binary_stream)
    - [get_os_args](#get_os_args)
    - [get_text_stream](#get_text_stream)
    - [make_default_short_help](#make_default_short_help)
    - [make_str](#make_str)
    - [open_file](#open_file)
    - [safecall](#safecall)

## KeepOpenFile

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L159)

```python
class KeepOpenFile(object):
    def __init__(file):
```

## LazyFile

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L83)

```python
class LazyFile(object):
    def __init__(
        filename,
        mode='r',
        encoding=None,
        errors='strict',
        atomic=False,
    ):
```

A lazy file works like a regular file but it does not fully open
the file but it does perform some basic checks early to see if the
filename parameter does make sense.  This is useful for safely opening
files for writing.

### LazyFile().close

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L136)

```python
def close():
```

Closes the underlying file, no matter what.

### LazyFile().close_intelligently

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L141)

```python
def close_intelligently():
```

This function only closes the file if it was opened by the lazy
file wrapper.  For instance this will never close stdin.

### LazyFile().open

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L118)

```python
def open():
```

Opens the file if it's not yet open.  This call might fail with
a exception `FileError`.  Not handling this error will produce an error
that Click shows.

## PacifyFlushWrapper

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L433)

```python
class PacifyFlushWrapper(object):
    def __init__(wrapped):
```

This wrapper is used to catch and suppress BrokenPipeErrors resulting
from ``.flush()`` being called on broken pipe during the shutdown/final-GC
of the Python interpreter. Notably ``.flush()`` is always called on
``sys.stdout`` and ``sys.stderr``. So as to have minimal impact on any
other cleanup code, and the case where the underlying file is not a broken
pipe, all calls and attributes are proxied.

### PacifyFlushWrapper().flush

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L445)

```python
def flush():
```

## echo

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L179)

```python
def echo(message=None, file=None, nl=True, err=False, color=None):
```

Prints a message plus a newline to the given file or stdout.  On
first sight, this looks like the print function, but it has improved
support for handling Unicode and binary data that does not fail no
matter how badly configured the system is.

Primarily it means that you can print binary data as well as Unicode
data on both 2.x and 3.x to the given file in the most appropriate way
possible.  This is a very carefree function in that it will try its
best to not fail.  As of Click 6.0 this includes support for unicode
output on the Windows console.

In addition to that, if `colorama`_ is installed, the echo function will
also support clever handling of ANSI codes.  Essentially it will then
do the following:

-   add transparent handling of ANSI color codes on Windows.
-   hide ANSI codes automatically if the destination file is not a
    terminal.

.. _colorama: https://pypi.org/project/colorama/

#### Notes

Changed in version 6.0
   As of Click 6.0 the echo function will properly support unicode
   output on the windows console.  Not that click does not modify
   the interpreter in any way which means that `sys.stdout` or the
   print statement or function will still not provide unicode support.

Changed in version 2.0
   Starting with version 2.0 of Click, the echo function will work
   with colorama if it's installed.

Added in version 3.0
   The `err` parameter was added.

Changed in version 4.0
   Added the `color` flag.

#### Arguments

- `message` - the message to print
- `file` - the file to write to (defaults to ``stdout``)
- `err` - if set to true the file defaults to ``stderr`` instead of
            ``stdout``.  This is faster and easier than calling
            :func:`get_text_stderr` yourself.
- `nl` - if set to `True` (the default) a newline is printed afterwards.
- `color` - controls if the terminal supports ANSI colors or not.  The
              default is autodetection.

## format_filename

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L363)

```python
def format_filename(filename, shorten=False):
```

Formats a filename for user display.  The main purpose of this
function is to ensure that the filename can be displayed at all.  This
will decode the filename to unicode if necessary in a way that it will
not fail.  Optionally, it can shorten the filename to not include the
full path to the filename.

#### Arguments

- `filename` - formats a filename for UI display.  This will also convert
                 the filename into unicode without failing.
- `shorten` - this optionally shortens the filename to strip of the
                path that leads up to it.

## get_app_dir

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L380)

```python
def get_app_dir(app_name, roaming=True, force_posix=False):
```

Returns the config folder for the application.  The default behavior
is to return whatever is most appropriate for the operating system.

To give you an idea, for an app called ``"Foo Bar"``, something like
the following folders could be returned:

Mac OS X:
  ``~/Library/Application Support/Foo Bar``
Mac OS X (POSIX):
  ``~/.foo-bar``
Unix:
  ``~/.config/foo-bar``
Unix (POSIX):
  ``~/.foo-bar``
Win XP (roaming):
  ``C:\Documents and Settings\<user>\Local Settings\Application Data\Foo Bar``
Win XP (not roaming):
  ``C:\Documents and Settings\<user>\Application Data\Foo Bar``
Win 7 (roaming):
  ``C:\Users\<user>\AppData\Roaming\Foo Bar``
Win 7 (not roaming):
  ``C:\Users\<user>\AppData\Local\Foo Bar``

#### Notes

Added in version 2.0

#### Arguments

- `app_name` - the application name.  This should be properly capitalized
                 and can contain whitespace.
- `roaming` - controls if the folder should be roaming or not on Windows.
                Has no affect otherwise.
- `force_posix` - if this is set to `True` then on any POSIX system the
                    folder will be stored in the home folder with a leading
                    dot instead of the XDG config home or darwin's
                    application support folder.

## get_binary_stream

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L276)

```python
def get_binary_stream(name):
```

Returns a system stream for byte processing.  This essentially
returns the stream from the sys module with the given name but it
solves some compatibility issues between different Python versions.
Primarily this function is necessary for getting binary streams on
Python 3.

#### Arguments

- `name` - the name of the stream to open.  Valid names are ``'stdin'``,
             ``'stdout'`` and ``'stderr'``

## get_os_args

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L342)

```python
def get_os_args():
```

This returns the argument part of sys.argv in the most appropriate
form for processing.  What this means is that this return value is in
a format that works for Click to process but does not necessarily
correspond well to what's actually standard for the interpreter.

On most environments the return value is ``sys.argv[:1]`` unchanged.
However if you are on Windows and running Python 2 the return value
will actually be a list of unicode strings instead because the
default behavior on that platform otherwise will not be able to
carry all possible values that sys.argv can have.

#### Notes

Added in version 6.0

## get_text_stream

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L292)

```python
def get_text_stream(name, encoding=None, errors='strict'):
```

Returns a system stream for text processing.  This usually returns
a wrapped stream around a binary stream returned from
:func:[get_binary_stream](#get_binary_stream) but it also can take shortcuts on Python 3
for already correctly configured streams.

#### Arguments

- `name` - the name of the stream to open.  Valid names are ``'stdin'``,
             ``'stdout'`` and ``'stderr'``
- `encoding` - overrides the detected default encoding.
- `errors` - overrides the default error mode.

## make_default_short_help

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L58)

```python
def make_default_short_help(help, max_length=45):
```

Return a condensed version of help string.

## make_str

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L48)

```python
def make_str(value):
```

Converts a value into a valid string.

## open_file

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L309)

```python
def open_file(
    filename,
    mode='r',
    encoding=None,
    errors='strict',
    lazy=False,
    atomic=False,
):
```

This is similar to how the class `File` works but for manual
usage.  Files are opened non lazy by default.  This can open regular
files as well as stdin/stdout if ``'-'`` is passed.

If stdin/stdout is returned the stream is wrapped so that the context
manager will not close the stream accidentally.  This makes it possible
to always use the function like this without having to worry to
accidentally close a standard stream

```python
with open_file(filename) as f:
    ...
```

#### Notes

Added in version 3.0

#### Arguments

- `filename` - the name of the file to open (or ``'-'`` for stdin/stdout).
- `mode` - the mode in which to open the file.
- `encoding` - the encoding to use.
- `errors` - the error handling for this file.
- `lazy` - can be flipped to true to open the file lazily.
- `atomic` - in atomic mode writes go into a temporary file and it's
               moved on close.

## safecall

[[find in source code]](..\..\..\..\..\env\Lib\site-packages\click\utils.py#L36)

```python
def safecall(func):
```

Wraps a function so that it swallows exceptions.
